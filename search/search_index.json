{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Brix","text":"<p>CLI for dbt project and profile management with Databricks focus</p> <p> </p>"},{"location":"#what-is-brix","title":"What is Brix?","text":"<p>Brix is a command-line tool that simplifies dbt project and profile management. It wraps the dbt CLI, adding convenience commands while allowing full passthrough to native dbt commands.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Profile Management - Initialize, view, and edit <code>profiles.yml</code> with interactive or CLI modes</li> <li>Project Scaffolding - Create new dbt projects with sensible defaults and package management</li> <li>dbt Passthrough - Run any dbt command through brix (<code>brix dbt run</code>, <code>brix dbt test</code>, etc.)</li> <li>Multiple Adapters - Built-in support for DuckDB (local development) and Databricks</li> <li>Interactive &amp; CLI Modes - Use guided wizards or script with CLI flags</li> </ul>"},{"location":"#quick-install","title":"Quick Install","text":"<pre><code>pip install brix\n</code></pre> <p>Or with uv:</p> <pre><code>uv tool install brix\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># Initialize a dbt profile\nbrix dbt profile init\n\n# Create a new dbt project\nbrix dbt project init\n\n# Run dbt commands through brix\nbrix dbt run\nbrix dbt test\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Installation - Detailed installation instructions</li> <li>Quick Start - Get up and running in minutes</li> <li>User Guide - Complete command reference</li> <li>Developer Guide - Contribute to brix</li> <li>API Reference - Python API documentation</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License - see LICENSE for details.</p>"},{"location":"api/","title":"API Reference","text":"<p>Brix can be used as a Python library in addition to the CLI.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>The brix package is organized into modules that can be imported directly:</p> <pre><code>from brix.modules.dbt.profile.models import DbtProfiles, DuckDbOutput\nfrom brix.modules.dbt.profile.service import init_profile\nfrom brix.modules.dbt.project.models import DbtProject\n</code></pre>"},{"location":"api/#package-structure","title":"Package Structure","text":"<pre><code>brix.modules.dbt.profile\n\u251c\u2500\u2500 models      # Pydantic models for profiles.yml\n\u251c\u2500\u2500 service     # Profile initialization and operations\n\u251c\u2500\u2500 editor      # Profile CRUD operations\n\u2514\u2500\u2500 prompts     # Interactive prompts\n\nbrix.modules.dbt.project\n\u251c\u2500\u2500 models      # Pydantic models for dbt_project.yml\n\u251c\u2500\u2500 service     # Project initialization\n\u251c\u2500\u2500 editor      # Project CRUD operations\n\u251c\u2500\u2500 finder      # Project discovery\n\u2514\u2500\u2500 prompts     # Interactive prompts\n\nbrix.utils\n\u2514\u2500\u2500 logging     # Terraform-style logger\n</code></pre>"},{"location":"api/#quick-examples","title":"Quick Examples","text":""},{"location":"api/#working-with-profiles","title":"Working with Profiles","text":"<pre><code>from brix.modules.dbt.profile.models import DbtProfiles, DuckDbOutput\n\n# Create a profile programmatically\nprofiles = DbtProfiles(\n    profiles={\n        \"my_project\": {\n            \"target\": \"dev\",\n            \"outputs\": {\n                \"dev\": DuckDbOutput(path=\"./dev.duckdb\"),\n            },\n        },\n    },\n)\n\n# Serialize to YAML\nyaml_content = profiles.to_yaml()\n\n# Parse from YAML\nloaded = DbtProfiles.from_yaml(yaml_content)\n</code></pre>"},{"location":"api/#working-with-projects","title":"Working with Projects","text":"<pre><code>from brix.modules.dbt.project.models import DbtProject\n\n# Load a project\nwith open(\"dbt_project.yml\") as f:\n    project = DbtProject.from_yaml(f.read())\n\n# Modify\nproject.name = \"new_name\"\n\n# Save\nwith open(\"dbt_project.yml\", \"w\") as f:\n    f.write(project.to_yaml())\n</code></pre>"},{"location":"api/#reference-sections","title":"Reference Sections","text":"<ul> <li>Modules - Service and editor functions</li> <li>Models - Pydantic data models</li> </ul>"},{"location":"api/models/","title":"Models Reference","text":"<p>Auto-generated API documentation for brix Pydantic models.</p>"},{"location":"api/models/#profile-models","title":"Profile Models","text":""},{"location":"api/models/#brix.modules.dbt.profile.models","title":"<code>brix.modules.dbt.profile.models</code>","text":"<p>Pydantic models for dbt profile configuration.</p> <p>These models provide type-safe parsing and validation of dbt profiles.yml files. Supports DuckDB and Databricks adapters.</p>"},{"location":"api/models/#brix.modules.dbt.profile.models.DuckDbOutput","title":"<code>DuckDbOutput</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>DuckDB adapter output configuration.</p> <p>Supports all dbt-duckdb adapter options including extensions and settings.</p> Source code in <code>src/brix/modules/dbt/profile/models.py</code> <pre><code>class DuckDbOutput(BaseModel):\n    \"\"\"DuckDB adapter output configuration.\n\n    Supports all dbt-duckdb adapter options including extensions and settings.\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"allow\", populate_by_name=True)\n\n    type: Literal[\"duckdb\"]\n    path: str = \":memory:\"\n    schema_: str = Field(default=\"main\", alias=\"schema\")\n    database: str = \"main\"\n    threads: int = 1\n    extensions: list[str] = Field(default_factory=list)\n    settings: dict[str, Any] = Field(default_factory=dict)\n\n    @model_validator(mode=\"after\")\n    def sync_database_with_memory_path(self) -&gt; Self:\n        \"\"\"Set database to 'memory' when path is ':memory:' for dbt-duckdb compatibility.\"\"\"\n        if self.path == \":memory:\" and self.database != \"memory\":\n            self.database = \"memory\"\n        return self\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.profile.models.DuckDbOutput.sync_database_with_memory_path","title":"<code>sync_database_with_memory_path()</code>","text":"<p>Set database to 'memory' when path is ':memory:' for dbt-duckdb compatibility.</p> Source code in <code>src/brix/modules/dbt/profile/models.py</code> <pre><code>@model_validator(mode=\"after\")\ndef sync_database_with_memory_path(self) -&gt; Self:\n    \"\"\"Set database to 'memory' when path is ':memory:' for dbt-duckdb compatibility.\"\"\"\n    if self.path == \":memory:\" and self.database != \"memory\":\n        self.database = \"memory\"\n    return self\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.profile.models.DatabricksOutput","title":"<code>DatabricksOutput</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Databricks adapter output configuration.</p> <p>Supports multiple authentication methods: - Token-based: Personal Access Token (PAT) - OAuth U2M: User-to-machine (browser-based, no secrets needed) - OAuth M2M (AWS/GCP): Machine-to-machine with client_id/client_secret - OAuth M2M (Azure): Machine-to-machine with azure_client_id/azure_client_secret</p> Source code in <code>src/brix/modules/dbt/profile/models.py</code> <pre><code>class DatabricksOutput(BaseModel):\n    \"\"\"Databricks adapter output configuration.\n\n    Supports multiple authentication methods:\n    - Token-based: Personal Access Token (PAT)\n    - OAuth U2M: User-to-machine (browser-based, no secrets needed)\n    - OAuth M2M (AWS/GCP): Machine-to-machine with client_id/client_secret\n    - OAuth M2M (Azure): Machine-to-machine with azure_client_id/azure_client_secret\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"allow\", populate_by_name=True)\n\n    type: Literal[\"databricks\"]\n\n    # Required connection fields\n    schema_: str = Field(alias=\"schema\")\n    host: str\n    http_path: str\n\n    # Authentication - exactly one method required (validated via model_validator)\n    token: str | None = None\n    auth_type: DatabricksAuthType | None = None\n    client_id: str | None = None\n    client_secret: str | None = None\n    azure_client_id: str | None = None\n    azure_client_secret: str | None = None\n\n    # Optional fields\n    catalog: str | None = None\n    threads: int = 1\n    connect_retries: int = 0\n    connect_timeout: int | None = None\n\n    @field_validator(\"host\", mode=\"before\")\n    @classmethod\n    def strip_host_protocol(cls, v: str) -&gt; str:\n        \"\"\"Strip http:// or https:// prefix from host if present.\"\"\"\n        if isinstance(v, str):\n            if v.startswith(\"https://\"):\n                return v[8:]\n            if v.startswith(\"http://\"):\n                return v[7:]\n        return v\n\n    @field_validator(\"http_path\", mode=\"before\")\n    @classmethod\n    def ensure_http_path_starts_with_slash(cls, v: str) -&gt; str:\n        \"\"\"Ensure http_path starts with /.\"\"\"\n        if isinstance(v, str) and not v.startswith(\"/\"):\n            return f\"/{v}\"\n        return v\n\n    @field_validator(\"threads\", mode=\"after\")\n    @classmethod\n    def validate_threads(cls, v: int) -&gt; int:\n        \"\"\"Ensure threads is at least 1.\"\"\"\n        if v &lt; 1:\n            msg = \"threads must be at least 1\"\n            raise ValueError(msg)\n        return v\n\n    @field_validator(\"connect_retries\", mode=\"after\")\n    @classmethod\n    def validate_connect_retries(cls, v: int) -&gt; int:\n        \"\"\"Ensure connect_retries is non-negative.\"\"\"\n        if v &lt; 0:\n            msg = \"connect_retries must be non-negative\"\n            raise ValueError(msg)\n        return v\n\n    @model_validator(mode=\"after\")\n    def validate_auth_method(self) -&gt; Self:\n        \"\"\"Validate that exactly one authentication method is configured.\n\n        Valid configurations:\n        - token alone (PAT)\n        - auth_type='oauth' alone (U2M)\n        - auth_type='oauth' + client_id + client_secret (M2M AWS/GCP)\n        - auth_type='oauth' + azure_client_id + azure_client_secret (M2M Azure)\n        \"\"\"\n        has_token = self.token is not None\n        has_oauth = self.auth_type == \"oauth\"\n        has_client_creds = self.client_id is not None or self.client_secret is not None\n        has_azure_creds = self.azure_client_id is not None or self.azure_client_secret is not None\n\n        # Token-based auth\n        if has_token:\n            if has_oauth or has_client_creds or has_azure_creds:\n                msg = \"Cannot use token authentication with OAuth settings\"\n                raise ValueError(msg)\n            return self\n\n        # OAuth-based auth\n        if has_oauth:\n            # Validate client credentials are complete if provided\n            if has_client_creds:\n                if not (self.client_id and self.client_secret):\n                    msg = \"Both client_id and client_secret are required for OAuth M2M (AWS/GCP)\"\n                    raise ValueError(msg)\n                if has_azure_creds:\n                    msg = \"Cannot mix AWS/GCP and Azure OAuth credentials\"\n                    raise ValueError(msg)\n                return self\n\n            # Validate Azure credentials are complete if provided\n            if has_azure_creds:\n                if not (self.azure_client_id and self.azure_client_secret):\n                    msg = \"Both azure_client_id and azure_client_secret are required for OAuth M2M (Azure)\"\n                    raise ValueError(msg)\n                return self\n\n            # U2M OAuth (no credentials needed)\n            return self\n\n        # No auth configured - allow this for profiles with env var references\n        # The connection test will catch invalid configurations at runtime\n        if has_client_creds or has_azure_creds:\n            msg = \"OAuth credentials require auth_type='oauth'\"\n            raise ValueError(msg)\n\n        return self\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.profile.models.DatabricksOutput.strip_host_protocol","title":"<code>strip_host_protocol(v)</code>  <code>classmethod</code>","text":"<p>Strip http:// or https:// prefix from host if present.</p> Source code in <code>src/brix/modules/dbt/profile/models.py</code> <pre><code>@field_validator(\"host\", mode=\"before\")\n@classmethod\ndef strip_host_protocol(cls, v: str) -&gt; str:\n    \"\"\"Strip http:// or https:// prefix from host if present.\"\"\"\n    if isinstance(v, str):\n        if v.startswith(\"https://\"):\n            return v[8:]\n        if v.startswith(\"http://\"):\n            return v[7:]\n    return v\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.profile.models.DatabricksOutput.ensure_http_path_starts_with_slash","title":"<code>ensure_http_path_starts_with_slash(v)</code>  <code>classmethod</code>","text":"<p>Ensure http_path starts with /.</p> Source code in <code>src/brix/modules/dbt/profile/models.py</code> <pre><code>@field_validator(\"http_path\", mode=\"before\")\n@classmethod\ndef ensure_http_path_starts_with_slash(cls, v: str) -&gt; str:\n    \"\"\"Ensure http_path starts with /.\"\"\"\n    if isinstance(v, str) and not v.startswith(\"/\"):\n        return f\"/{v}\"\n    return v\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.profile.models.DatabricksOutput.validate_threads","title":"<code>validate_threads(v)</code>  <code>classmethod</code>","text":"<p>Ensure threads is at least 1.</p> Source code in <code>src/brix/modules/dbt/profile/models.py</code> <pre><code>@field_validator(\"threads\", mode=\"after\")\n@classmethod\ndef validate_threads(cls, v: int) -&gt; int:\n    \"\"\"Ensure threads is at least 1.\"\"\"\n    if v &lt; 1:\n        msg = \"threads must be at least 1\"\n        raise ValueError(msg)\n    return v\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.profile.models.DatabricksOutput.validate_connect_retries","title":"<code>validate_connect_retries(v)</code>  <code>classmethod</code>","text":"<p>Ensure connect_retries is non-negative.</p> Source code in <code>src/brix/modules/dbt/profile/models.py</code> <pre><code>@field_validator(\"connect_retries\", mode=\"after\")\n@classmethod\ndef validate_connect_retries(cls, v: int) -&gt; int:\n    \"\"\"Ensure connect_retries is non-negative.\"\"\"\n    if v &lt; 0:\n        msg = \"connect_retries must be non-negative\"\n        raise ValueError(msg)\n    return v\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.profile.models.DatabricksOutput.validate_auth_method","title":"<code>validate_auth_method()</code>","text":"<p>Validate that exactly one authentication method is configured.</p> <p>Valid configurations: - token alone (PAT) - auth_type='oauth' alone (U2M) - auth_type='oauth' + client_id + client_secret (M2M AWS/GCP) - auth_type='oauth' + azure_client_id + azure_client_secret (M2M Azure)</p> Source code in <code>src/brix/modules/dbt/profile/models.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_auth_method(self) -&gt; Self:\n    \"\"\"Validate that exactly one authentication method is configured.\n\n    Valid configurations:\n    - token alone (PAT)\n    - auth_type='oauth' alone (U2M)\n    - auth_type='oauth' + client_id + client_secret (M2M AWS/GCP)\n    - auth_type='oauth' + azure_client_id + azure_client_secret (M2M Azure)\n    \"\"\"\n    has_token = self.token is not None\n    has_oauth = self.auth_type == \"oauth\"\n    has_client_creds = self.client_id is not None or self.client_secret is not None\n    has_azure_creds = self.azure_client_id is not None or self.azure_client_secret is not None\n\n    # Token-based auth\n    if has_token:\n        if has_oauth or has_client_creds or has_azure_creds:\n            msg = \"Cannot use token authentication with OAuth settings\"\n            raise ValueError(msg)\n        return self\n\n    # OAuth-based auth\n    if has_oauth:\n        # Validate client credentials are complete if provided\n        if has_client_creds:\n            if not (self.client_id and self.client_secret):\n                msg = \"Both client_id and client_secret are required for OAuth M2M (AWS/GCP)\"\n                raise ValueError(msg)\n            if has_azure_creds:\n                msg = \"Cannot mix AWS/GCP and Azure OAuth credentials\"\n                raise ValueError(msg)\n            return self\n\n        # Validate Azure credentials are complete if provided\n        if has_azure_creds:\n            if not (self.azure_client_id and self.azure_client_secret):\n                msg = \"Both azure_client_id and azure_client_secret are required for OAuth M2M (Azure)\"\n                raise ValueError(msg)\n            return self\n\n        # U2M OAuth (no credentials needed)\n        return self\n\n    # No auth configured - allow this for profiles with env var references\n    # The connection test will catch invalid configurations at runtime\n    if has_client_creds or has_azure_creds:\n        msg = \"OAuth credentials require auth_type='oauth'\"\n        raise ValueError(msg)\n\n    return self\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.profile.models.ProfileTarget","title":"<code>ProfileTarget</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A dbt profile with target selection and output configurations.</p> Source code in <code>src/brix/modules/dbt/profile/models.py</code> <pre><code>class ProfileTarget(BaseModel):\n    \"\"\"A dbt profile with target selection and output configurations.\"\"\"\n\n    model_config = ConfigDict(extra=\"allow\")\n\n    target: str\n    outputs: dict[str, OutputConfig]\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.profile.models.DbtProfiles","title":"<code>DbtProfiles</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Root model for profiles.yml - a mapping of profile names to configurations.</p> Source code in <code>src/brix/modules/dbt/profile/models.py</code> <pre><code>class DbtProfiles(BaseModel):\n    \"\"\"Root model for profiles.yml - a mapping of profile names to configurations.\"\"\"\n\n    model_config = ConfigDict(extra=\"allow\")\n\n    root: dict[str, ProfileTarget]\n\n    def __getitem__(self, key: str) -&gt; ProfileTarget:\n        \"\"\"Allow dict-like access to profiles.\"\"\"\n        return self.root[key]\n\n    def __contains__(self, key: str) -&gt; bool:\n        \"\"\"Check if profile exists.\"\"\"\n        return key in self.root\n\n    @classmethod\n    def from_yaml(cls, content: str) -&gt; DbtProfiles:\n        \"\"\"Parse profiles from YAML string.\n\n        Args:\n            content: YAML string content of profiles.yml\n\n        Returns:\n            Parsed DbtProfiles instance\n\n        Raises:\n            ValueError: If YAML is invalid or doesn't match schema\n        \"\"\"\n        import yaml\n\n        try:\n            data = yaml.safe_load(content)\n        except yaml.YAMLError as e:\n            msg = f\"Invalid YAML: {e}\"\n            raise ValueError(msg) from e\n\n        if not isinstance(data, dict):\n            msg = \"profiles.yml must be a YAML mapping\"\n            raise ValueError(msg)\n\n        return cls(root=data)\n\n    @classmethod\n    def from_file(cls, path: Path) -&gt; DbtProfiles:\n        \"\"\"Load profiles from a file path.\n\n        Args:\n            path: Path to profiles.yml file\n\n        Returns:\n            Parsed DbtProfiles instance\n\n        Raises:\n            FileNotFoundError: If file doesn't exist\n            ValueError: If YAML is invalid or doesn't match schema\n        \"\"\"\n        content = path.read_text()\n        return cls.from_yaml(content)\n\n    def to_yaml(self) -&gt; str:\n        \"\"\"Serialize profiles to YAML string.\n\n        Returns:\n            YAML string representation\n        \"\"\"\n        import yaml\n\n        # Convert to dict, handling nested models\n        # Use by_alias=True to output 'schema' instead of 'schema_'\n        data = {name: profile.model_dump(exclude_none=True, by_alias=True) for name, profile in self.root.items()}\n        return yaml.dump(data, default_flow_style=False, sort_keys=False)\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.profile.models.DbtProfiles.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Allow dict-like access to profiles.</p> Source code in <code>src/brix/modules/dbt/profile/models.py</code> <pre><code>def __getitem__(self, key: str) -&gt; ProfileTarget:\n    \"\"\"Allow dict-like access to profiles.\"\"\"\n    return self.root[key]\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.profile.models.DbtProfiles.__contains__","title":"<code>__contains__(key)</code>","text":"<p>Check if profile exists.</p> Source code in <code>src/brix/modules/dbt/profile/models.py</code> <pre><code>def __contains__(self, key: str) -&gt; bool:\n    \"\"\"Check if profile exists.\"\"\"\n    return key in self.root\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.profile.models.DbtProfiles.from_yaml","title":"<code>from_yaml(content)</code>  <code>classmethod</code>","text":"<p>Parse profiles from YAML string.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>YAML string content of profiles.yml</p> required <p>Returns:</p> Type Description <code>DbtProfiles</code> <p>Parsed DbtProfiles instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If YAML is invalid or doesn't match schema</p> Source code in <code>src/brix/modules/dbt/profile/models.py</code> <pre><code>@classmethod\ndef from_yaml(cls, content: str) -&gt; DbtProfiles:\n    \"\"\"Parse profiles from YAML string.\n\n    Args:\n        content: YAML string content of profiles.yml\n\n    Returns:\n        Parsed DbtProfiles instance\n\n    Raises:\n        ValueError: If YAML is invalid or doesn't match schema\n    \"\"\"\n    import yaml\n\n    try:\n        data = yaml.safe_load(content)\n    except yaml.YAMLError as e:\n        msg = f\"Invalid YAML: {e}\"\n        raise ValueError(msg) from e\n\n    if not isinstance(data, dict):\n        msg = \"profiles.yml must be a YAML mapping\"\n        raise ValueError(msg)\n\n    return cls(root=data)\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.profile.models.DbtProfiles.from_file","title":"<code>from_file(path)</code>  <code>classmethod</code>","text":"<p>Load profiles from a file path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to profiles.yml file</p> required <p>Returns:</p> Type Description <code>DbtProfiles</code> <p>Parsed DbtProfiles instance</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> <code>ValueError</code> <p>If YAML is invalid or doesn't match schema</p> Source code in <code>src/brix/modules/dbt/profile/models.py</code> <pre><code>@classmethod\ndef from_file(cls, path: Path) -&gt; DbtProfiles:\n    \"\"\"Load profiles from a file path.\n\n    Args:\n        path: Path to profiles.yml file\n\n    Returns:\n        Parsed DbtProfiles instance\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n        ValueError: If YAML is invalid or doesn't match schema\n    \"\"\"\n    content = path.read_text()\n    return cls.from_yaml(content)\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.profile.models.DbtProfiles.to_yaml","title":"<code>to_yaml()</code>","text":"<p>Serialize profiles to YAML string.</p> <p>Returns:</p> Type Description <code>str</code> <p>YAML string representation</p> Source code in <code>src/brix/modules/dbt/profile/models.py</code> <pre><code>def to_yaml(self) -&gt; str:\n    \"\"\"Serialize profiles to YAML string.\n\n    Returns:\n        YAML string representation\n    \"\"\"\n    import yaml\n\n    # Convert to dict, handling nested models\n    # Use by_alias=True to output 'schema' instead of 'schema_'\n    data = {name: profile.model_dump(exclude_none=True, by_alias=True) for name, profile in self.root.items()}\n    return yaml.dump(data, default_flow_style=False, sort_keys=False)\n</code></pre>"},{"location":"api/models/#project-models","title":"Project Models","text":""},{"location":"api/models/#brix.modules.dbt.project.models","title":"<code>brix.modules.dbt.project.models</code>","text":"<p>Pydantic models for dbt project configuration.</p> <p>These models provide type-safe parsing and validation of dbt_project.yml and packages.yml files.</p>"},{"location":"api/models/#brix.modules.dbt.project.models.ProjectNameError","title":"<code>ProjectNameError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when project name is invalid.</p> Source code in <code>src/brix/modules/dbt/project/models.py</code> <pre><code>class ProjectNameError(ValueError):\n    \"\"\"Raised when project name is invalid.\"\"\"\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.project.models.PackageNameError","title":"<code>PackageNameError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when package name is invalid.</p> Source code in <code>src/brix/modules/dbt/project/models.py</code> <pre><code>class PackageNameError(ValueError):\n    \"\"\"Raised when package name is invalid.\"\"\"\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.project.models.DbtProject","title":"<code>DbtProject</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model for dbt_project.yml configuration.</p> <p>Represents the structure and configuration options for a dbt project. Supports YAML serialization via from_yaml() and to_yaml() methods.</p> Source code in <code>src/brix/modules/dbt/project/models.py</code> <pre><code>class DbtProject(BaseModel):\n    \"\"\"Pydantic model for dbt_project.yml configuration.\n\n    Represents the structure and configuration options for a dbt project.\n    Supports YAML serialization via from_yaml() and to_yaml() methods.\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"allow\", populate_by_name=True)\n\n    # Required fields\n    name: str\n    profile: str\n\n    # Version fields\n    version: str = \"1.0.0\"\n    config_version: Literal[2] = Field(default=2, alias=\"config-version\")\n\n    # Path configurations\n    model_paths: list[str] = Field(default=[\"models\"], alias=\"model-paths\")\n    seed_paths: list[str] = Field(default=[\"seeds\"], alias=\"seed-paths\")\n    test_paths: list[str] = Field(default=[\"tests\"], alias=\"test-paths\")\n    macro_paths: list[str] = Field(default=[\"macros\"], alias=\"macro-paths\")\n    snapshot_paths: list[str] = Field(default=[\"snapshots\"], alias=\"snapshot-paths\")\n    analysis_paths: list[str] = Field(default=[\"analyses\"], alias=\"analysis-paths\")\n    asset_paths: list[str] = Field(default=[\"assets\"], alias=\"asset-paths\")\n\n    # Build configuration\n    clean_targets: list[str] = Field(default=[\"target\", \"dbt_packages\"], alias=\"clean-targets\")\n    require_dbt_version: str | None = Field(default=None, alias=\"require-dbt-version\")\n\n    # Model defaults (optional)\n    models: dict[str, Any] | None = None\n    seeds: dict[str, Any] | None = None\n    vars: dict[str, Any] | None = None\n\n    @field_validator(\"name\", mode=\"after\")\n    @classmethod\n    def validate_name(cls, v: str) -&gt; str:\n        \"\"\"Validate project name follows dbt requirements.\"\"\"\n        return validate_project_name(v)\n\n    @classmethod\n    def from_yaml(cls, content: str) -&gt; DbtProject:\n        \"\"\"Parse project configuration from YAML string.\n\n        Args:\n            content: YAML string content of dbt_project.yml\n\n        Returns:\n            Parsed DbtProject instance\n\n        Raises:\n            ValueError: If YAML is invalid or doesn't match schema\n        \"\"\"\n        try:\n            data = yaml.safe_load(content)\n        except yaml.YAMLError as e:\n            msg = f\"Invalid YAML: {e}\"\n            raise ValueError(msg) from e\n\n        if not isinstance(data, dict):\n            msg = \"dbt_project.yml must be a YAML mapping\"\n            raise ValueError(msg)\n\n        return cls(**data)\n\n    @classmethod\n    def from_file(cls, path: Path) -&gt; DbtProject:\n        \"\"\"Load project configuration from a file path.\n\n        Args:\n            path: Path to dbt_project.yml file\n\n        Returns:\n            Parsed DbtProject instance\n\n        Raises:\n            FileNotFoundError: If file doesn't exist\n            ValueError: If YAML is invalid or doesn't match schema\n        \"\"\"\n        content = path.read_text()\n        return cls.from_yaml(content)\n\n    def to_yaml(self) -&gt; str:\n        \"\"\"Serialize project configuration to YAML string.\n\n        Returns:\n            YAML string representation\n        \"\"\"\n        # Convert to dict, using aliases for YAML keys\n        data = self.model_dump(exclude_none=True, by_alias=True)\n        return yaml.dump(data, default_flow_style=False, sort_keys=False)\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.project.models.DbtProject.validate_name","title":"<code>validate_name(v)</code>  <code>classmethod</code>","text":"<p>Validate project name follows dbt requirements.</p> Source code in <code>src/brix/modules/dbt/project/models.py</code> <pre><code>@field_validator(\"name\", mode=\"after\")\n@classmethod\ndef validate_name(cls, v: str) -&gt; str:\n    \"\"\"Validate project name follows dbt requirements.\"\"\"\n    return validate_project_name(v)\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.project.models.DbtProject.from_yaml","title":"<code>from_yaml(content)</code>  <code>classmethod</code>","text":"<p>Parse project configuration from YAML string.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>YAML string content of dbt_project.yml</p> required <p>Returns:</p> Type Description <code>DbtProject</code> <p>Parsed DbtProject instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If YAML is invalid or doesn't match schema</p> Source code in <code>src/brix/modules/dbt/project/models.py</code> <pre><code>@classmethod\ndef from_yaml(cls, content: str) -&gt; DbtProject:\n    \"\"\"Parse project configuration from YAML string.\n\n    Args:\n        content: YAML string content of dbt_project.yml\n\n    Returns:\n        Parsed DbtProject instance\n\n    Raises:\n        ValueError: If YAML is invalid or doesn't match schema\n    \"\"\"\n    try:\n        data = yaml.safe_load(content)\n    except yaml.YAMLError as e:\n        msg = f\"Invalid YAML: {e}\"\n        raise ValueError(msg) from e\n\n    if not isinstance(data, dict):\n        msg = \"dbt_project.yml must be a YAML mapping\"\n        raise ValueError(msg)\n\n    return cls(**data)\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.project.models.DbtProject.from_file","title":"<code>from_file(path)</code>  <code>classmethod</code>","text":"<p>Load project configuration from a file path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to dbt_project.yml file</p> required <p>Returns:</p> Type Description <code>DbtProject</code> <p>Parsed DbtProject instance</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> <code>ValueError</code> <p>If YAML is invalid or doesn't match schema</p> Source code in <code>src/brix/modules/dbt/project/models.py</code> <pre><code>@classmethod\ndef from_file(cls, path: Path) -&gt; DbtProject:\n    \"\"\"Load project configuration from a file path.\n\n    Args:\n        path: Path to dbt_project.yml file\n\n    Returns:\n        Parsed DbtProject instance\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n        ValueError: If YAML is invalid or doesn't match schema\n    \"\"\"\n    content = path.read_text()\n    return cls.from_yaml(content)\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.project.models.DbtProject.to_yaml","title":"<code>to_yaml()</code>","text":"<p>Serialize project configuration to YAML string.</p> <p>Returns:</p> Type Description <code>str</code> <p>YAML string representation</p> Source code in <code>src/brix/modules/dbt/project/models.py</code> <pre><code>def to_yaml(self) -&gt; str:\n    \"\"\"Serialize project configuration to YAML string.\n\n    Returns:\n        YAML string representation\n    \"\"\"\n    # Convert to dict, using aliases for YAML keys\n    data = self.model_dump(exclude_none=True, by_alias=True)\n    return yaml.dump(data, default_flow_style=False, sort_keys=False)\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.project.models.HubPackage","title":"<code>HubPackage</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A package from the dbt Hub (hub.getdbt.com).</p> Example <ul> <li>package: dbt-labs/dbt_utils   version: \"&gt;=1.0.0\"</li> </ul> Source code in <code>src/brix/modules/dbt/project/models.py</code> <pre><code>class HubPackage(BaseModel):\n    \"\"\"A package from the dbt Hub (hub.getdbt.com).\n\n    Example:\n        - package: dbt-labs/dbt_utils\n          version: \"&gt;=1.0.0\"\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\")\n\n    package: str\n    version: str\n\n    @field_validator(\"package\", mode=\"after\")\n    @classmethod\n    def validate_package_name(cls, v: str) -&gt; str:\n        \"\"\"Validate package name follows hub format.\"\"\"\n        return validate_hub_package_name(v)\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.project.models.HubPackage.validate_package_name","title":"<code>validate_package_name(v)</code>  <code>classmethod</code>","text":"<p>Validate package name follows hub format.</p> Source code in <code>src/brix/modules/dbt/project/models.py</code> <pre><code>@field_validator(\"package\", mode=\"after\")\n@classmethod\ndef validate_package_name(cls, v: str) -&gt; str:\n    \"\"\"Validate package name follows hub format.\"\"\"\n    return validate_hub_package_name(v)\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.project.models.GitPackage","title":"<code>GitPackage</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A package from a Git repository.</p> Example <ul> <li>git: \"https://github.com/org/repo.git\"   revision: main   subdirectory: \"path/to/dbt_project\"</li> </ul> Source code in <code>src/brix/modules/dbt/project/models.py</code> <pre><code>class GitPackage(BaseModel):\n    \"\"\"A package from a Git repository.\n\n    Example:\n        - git: \"https://github.com/org/repo.git\"\n          revision: main\n          subdirectory: \"path/to/dbt_project\"\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\")\n\n    git: str\n    revision: str\n    subdirectory: str | None = None\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.project.models.LocalPackage","title":"<code>LocalPackage</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A package from the local filesystem.</p> Example <ul> <li>local: ../shared_macros</li> </ul> Source code in <code>src/brix/modules/dbt/project/models.py</code> <pre><code>class LocalPackage(BaseModel):\n    \"\"\"A package from the local filesystem.\n\n    Example:\n        - local: ../shared_macros\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\")\n\n    local: str\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.project.models.DbtPackages","title":"<code>DbtPackages</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model for packages.yml configuration.</p> <p>Represents the list of dbt packages to install.</p> Source code in <code>src/brix/modules/dbt/project/models.py</code> <pre><code>class DbtPackages(BaseModel):\n    \"\"\"Pydantic model for packages.yml configuration.\n\n    Represents the list of dbt packages to install.\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"forbid\")\n\n    packages: list[HubPackage | GitPackage | LocalPackage] = Field(default_factory=list)\n\n    @classmethod\n    def from_yaml(cls, content: str) -&gt; DbtPackages:\n        \"\"\"Parse packages configuration from YAML string.\n\n        Args:\n            content: YAML string content of packages.yml\n\n        Returns:\n            Parsed DbtPackages instance\n\n        Raises:\n            ValueError: If YAML is invalid or doesn't match schema\n        \"\"\"\n        try:\n            data = yaml.safe_load(content)\n        except yaml.YAMLError as e:\n            msg = f\"Invalid YAML: {e}\"\n            raise ValueError(msg) from e\n\n        if data is None:\n            return cls(packages=[])\n\n        if not isinstance(data, dict):\n            msg = \"packages.yml must be a YAML mapping\"\n            raise ValueError(msg)\n\n        return cls(**data)\n\n    @classmethod\n    def from_file(cls, path: Path) -&gt; DbtPackages:\n        \"\"\"Load packages configuration from a file path.\n\n        Args:\n            path: Path to packages.yml file\n\n        Returns:\n            Parsed DbtPackages instance\n\n        Raises:\n            FileNotFoundError: If file doesn't exist\n            ValueError: If YAML is invalid or doesn't match schema\n        \"\"\"\n        content = path.read_text()\n        return cls.from_yaml(content)\n\n    def to_yaml(self) -&gt; str:\n        \"\"\"Serialize packages configuration to YAML string.\n\n        Returns:\n            YAML string representation\n        \"\"\"\n        data = self.model_dump(exclude_none=True)\n        return yaml.dump(data, default_flow_style=False, sort_keys=False)\n\n    def add_hub_package(self, package: str, version: str) -&gt; None:\n        \"\"\"Add a hub package to the list.\n\n        Args:\n            package: Package name (e.g., \"dbt-labs/dbt_utils\")\n            version: Version specifier (e.g., \"&gt;=1.0.0\")\n        \"\"\"\n        self.packages.append(HubPackage(package=package, version=version))\n\n    def add_git_package(self, git: str, revision: str, subdirectory: str | None = None) -&gt; None:\n        \"\"\"Add a git package to the list.\n\n        Args:\n            git: Git repository URL\n            revision: Branch, tag, or commit hash\n            subdirectory: Optional subdirectory within repo\n        \"\"\"\n        self.packages.append(GitPackage(git=git, revision=revision, subdirectory=subdirectory))\n\n    def add_local_package(self, local: str) -&gt; None:\n        \"\"\"Add a local package to the list.\n\n        Args:\n            local: Local filesystem path\n        \"\"\"\n        self.packages.append(LocalPackage(local=local))\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.project.models.DbtPackages.from_yaml","title":"<code>from_yaml(content)</code>  <code>classmethod</code>","text":"<p>Parse packages configuration from YAML string.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>YAML string content of packages.yml</p> required <p>Returns:</p> Type Description <code>DbtPackages</code> <p>Parsed DbtPackages instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If YAML is invalid or doesn't match schema</p> Source code in <code>src/brix/modules/dbt/project/models.py</code> <pre><code>@classmethod\ndef from_yaml(cls, content: str) -&gt; DbtPackages:\n    \"\"\"Parse packages configuration from YAML string.\n\n    Args:\n        content: YAML string content of packages.yml\n\n    Returns:\n        Parsed DbtPackages instance\n\n    Raises:\n        ValueError: If YAML is invalid or doesn't match schema\n    \"\"\"\n    try:\n        data = yaml.safe_load(content)\n    except yaml.YAMLError as e:\n        msg = f\"Invalid YAML: {e}\"\n        raise ValueError(msg) from e\n\n    if data is None:\n        return cls(packages=[])\n\n    if not isinstance(data, dict):\n        msg = \"packages.yml must be a YAML mapping\"\n        raise ValueError(msg)\n\n    return cls(**data)\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.project.models.DbtPackages.from_file","title":"<code>from_file(path)</code>  <code>classmethod</code>","text":"<p>Load packages configuration from a file path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to packages.yml file</p> required <p>Returns:</p> Type Description <code>DbtPackages</code> <p>Parsed DbtPackages instance</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> <code>ValueError</code> <p>If YAML is invalid or doesn't match schema</p> Source code in <code>src/brix/modules/dbt/project/models.py</code> <pre><code>@classmethod\ndef from_file(cls, path: Path) -&gt; DbtPackages:\n    \"\"\"Load packages configuration from a file path.\n\n    Args:\n        path: Path to packages.yml file\n\n    Returns:\n        Parsed DbtPackages instance\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n        ValueError: If YAML is invalid or doesn't match schema\n    \"\"\"\n    content = path.read_text()\n    return cls.from_yaml(content)\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.project.models.DbtPackages.to_yaml","title":"<code>to_yaml()</code>","text":"<p>Serialize packages configuration to YAML string.</p> <p>Returns:</p> Type Description <code>str</code> <p>YAML string representation</p> Source code in <code>src/brix/modules/dbt/project/models.py</code> <pre><code>def to_yaml(self) -&gt; str:\n    \"\"\"Serialize packages configuration to YAML string.\n\n    Returns:\n        YAML string representation\n    \"\"\"\n    data = self.model_dump(exclude_none=True)\n    return yaml.dump(data, default_flow_style=False, sort_keys=False)\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.project.models.DbtPackages.add_hub_package","title":"<code>add_hub_package(package, version)</code>","text":"<p>Add a hub package to the list.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>Package name (e.g., \"dbt-labs/dbt_utils\")</p> required <code>version</code> <code>str</code> <p>Version specifier (e.g., \"&gt;=1.0.0\")</p> required Source code in <code>src/brix/modules/dbt/project/models.py</code> <pre><code>def add_hub_package(self, package: str, version: str) -&gt; None:\n    \"\"\"Add a hub package to the list.\n\n    Args:\n        package: Package name (e.g., \"dbt-labs/dbt_utils\")\n        version: Version specifier (e.g., \"&gt;=1.0.0\")\n    \"\"\"\n    self.packages.append(HubPackage(package=package, version=version))\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.project.models.DbtPackages.add_git_package","title":"<code>add_git_package(git, revision, subdirectory=None)</code>","text":"<p>Add a git package to the list.</p> <p>Parameters:</p> Name Type Description Default <code>git</code> <code>str</code> <p>Git repository URL</p> required <code>revision</code> <code>str</code> <p>Branch, tag, or commit hash</p> required <code>subdirectory</code> <code>str | None</code> <p>Optional subdirectory within repo</p> <code>None</code> Source code in <code>src/brix/modules/dbt/project/models.py</code> <pre><code>def add_git_package(self, git: str, revision: str, subdirectory: str | None = None) -&gt; None:\n    \"\"\"Add a git package to the list.\n\n    Args:\n        git: Git repository URL\n        revision: Branch, tag, or commit hash\n        subdirectory: Optional subdirectory within repo\n    \"\"\"\n    self.packages.append(GitPackage(git=git, revision=revision, subdirectory=subdirectory))\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.project.models.DbtPackages.add_local_package","title":"<code>add_local_package(local)</code>","text":"<p>Add a local package to the list.</p> <p>Parameters:</p> Name Type Description Default <code>local</code> <code>str</code> <p>Local filesystem path</p> required Source code in <code>src/brix/modules/dbt/project/models.py</code> <pre><code>def add_local_package(self, local: str) -&gt; None:\n    \"\"\"Add a local package to the list.\n\n    Args:\n        local: Local filesystem path\n    \"\"\"\n    self.packages.append(LocalPackage(local=local))\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.project.models.validate_project_name","title":"<code>validate_project_name(name)</code>","text":"<p>Validate a dbt project name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Project name to validate</p> required <p>Returns:</p> Type Description <code>str</code> <p>The validated project name</p> <p>Raises:</p> Type Description <code>ProjectNameError</code> <p>If name doesn't match dbt requirements</p> Source code in <code>src/brix/modules/dbt/project/models.py</code> <pre><code>def validate_project_name(name: str) -&gt; str:\n    \"\"\"Validate a dbt project name.\n\n    Args:\n        name: Project name to validate\n\n    Returns:\n        The validated project name\n\n    Raises:\n        ProjectNameError: If name doesn't match dbt requirements\n    \"\"\"\n    if not PROJECT_NAME_PATTERN.match(name):\n        msg = (\n            f\"Invalid project name: '{name}'. \"\n            \"Project name must start with a letter or underscore and contain only \"\n            \"alphanumeric characters and underscores.\"\n        )\n        raise ProjectNameError(msg)\n    return name\n</code></pre>"},{"location":"api/models/#brix.modules.dbt.project.models.validate_hub_package_name","title":"<code>validate_hub_package_name(name)</code>","text":"<p>Validate a dbt hub package name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Package name to validate (e.g., \"dbt-labs/dbt_utils\")</p> required <p>Returns:</p> Type Description <code>str</code> <p>The validated package name</p> <p>Raises:</p> Type Description <code>PackageNameError</code> <p>If name doesn't match hub package format</p> Source code in <code>src/brix/modules/dbt/project/models.py</code> <pre><code>def validate_hub_package_name(name: str) -&gt; str:\n    \"\"\"Validate a dbt hub package name.\n\n    Args:\n        name: Package name to validate (e.g., \"dbt-labs/dbt_utils\")\n\n    Returns:\n        The validated package name\n\n    Raises:\n        PackageNameError: If name doesn't match hub package format\n    \"\"\"\n    if not HUB_PACKAGE_PATTERN.match(name):\n        msg = (\n            f\"Invalid hub package name: '{name}'. \"\n            \"Package name must be in 'namespace/package' format \"\n            \"(e.g., 'dbt-labs/dbt_utils').\"\n        )\n        raise PackageNameError(msg)\n    return name\n</code></pre>"},{"location":"api/modules/","title":"Modules Reference","text":"<p>Auto-generated API documentation for brix modules.</p>"},{"location":"api/modules/#profile-service","title":"Profile Service","text":""},{"location":"api/modules/#brix.modules.dbt.profile.service","title":"<code>brix.modules.dbt.profile.service</code>","text":"<p>Profile management service for dbt profiles.yml.</p> <p>Handles loading templates, validating profiles, and writing to disk.</p>"},{"location":"api/modules/#brix.modules.dbt.profile.service.ProfileConfig","title":"<code>ProfileConfig</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Profile configuration from environment variables.</p> Environment variables <p>BRIX_DBT_PROFILE_PATH: Override default profile path</p> Source code in <code>src/brix/modules/dbt/profile/service.py</code> <pre><code>class ProfileConfig(BaseSettings):\n    \"\"\"Profile configuration from environment variables.\n\n    Environment variables:\n        BRIX_DBT_PROFILE_PATH: Override default profile path\n    \"\"\"\n\n    model_config = SettingsConfigDict(\n        env_prefix=\"BRIX_DBT_\",\n        case_sensitive=False,\n    )\n\n    profile_path: Path | None = None\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.service.ProfileExistsError","title":"<code>ProfileExistsError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when profile already exists and force is not set.</p> Source code in <code>src/brix/modules/dbt/profile/service.py</code> <pre><code>class ProfileExistsError(Exception):\n    \"\"\"Raised when profile already exists and force is not set.\"\"\"\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.service.ProfileInitResult","title":"<code>ProfileInitResult</code>","text":"<p>Result of profile initialization.</p> Source code in <code>src/brix/modules/dbt/profile/service.py</code> <pre><code>class ProfileInitResult:\n    \"\"\"Result of profile initialization.\"\"\"\n\n    def __init__(\n        self,\n        *,\n        success: bool,\n        path: Path,\n        action: Literal[\"created\", \"overwritten\", \"skipped\"],\n        message: str,\n    ) -&gt; None:\n        \"\"\"Initialize profile init result.\n\n        Args:\n            success: Whether initialization succeeded\n            path: Path to the profile file\n            action: What action was taken (created, overwritten, skipped)\n            message: Human-readable result message\n        \"\"\"\n        self.success = success\n        self.path = path\n        self.action = action\n        self.message = message\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.service.ProfileInitResult.__init__","title":"<code>__init__(*, success, path, action, message)</code>","text":"<p>Initialize profile init result.</p> <p>Parameters:</p> Name Type Description Default <code>success</code> <code>bool</code> <p>Whether initialization succeeded</p> required <code>path</code> <code>Path</code> <p>Path to the profile file</p> required <code>action</code> <code>Literal['created', 'overwritten', 'skipped']</code> <p>What action was taken (created, overwritten, skipped)</p> required <code>message</code> <code>str</code> <p>Human-readable result message</p> required Source code in <code>src/brix/modules/dbt/profile/service.py</code> <pre><code>def __init__(\n    self,\n    *,\n    success: bool,\n    path: Path,\n    action: Literal[\"created\", \"overwritten\", \"skipped\"],\n    message: str,\n) -&gt; None:\n    \"\"\"Initialize profile init result.\n\n    Args:\n        success: Whether initialization succeeded\n        path: Path to the profile file\n        action: What action was taken (created, overwritten, skipped)\n        message: Human-readable result message\n    \"\"\"\n    self.success = success\n    self.path = path\n    self.action = action\n    self.message = message\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.service.get_default_profile_path","title":"<code>get_default_profile_path()</code>","text":"<p>Get the default profile path, checking env var first.</p> <p>Returns:</p> Type Description <code>Path</code> <p>Path from BRIX_DBT_PROFILE_PATH env var, or ~/.dbt/profiles.yml</p> Source code in <code>src/brix/modules/dbt/profile/service.py</code> <pre><code>def get_default_profile_path() -&gt; Path:\n    \"\"\"Get the default profile path, checking env var first.\n\n    Returns:\n        Path from BRIX_DBT_PROFILE_PATH env var, or ~/.dbt/profiles.yml\n    \"\"\"\n    config = ProfileConfig()\n    return config.profile_path or DEFAULT_PROFILE_PATH\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.service.load_template","title":"<code>load_template(template_name='profiles.yml')</code>","text":"<p>Load and validate the bundled profile template.</p> <p>Parameters:</p> Name Type Description Default <code>template_name</code> <code>str</code> <p>Name of the template file</p> <code>'profiles.yml'</code> <p>Returns:</p> Type Description <code>tuple[str, DbtProfiles]</code> <p>Tuple of (raw template content, validated DbtProfiles)</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If template doesn't exist</p> <code>ValueError</code> <p>If template is invalid YAML or doesn't match schema</p> Source code in <code>src/brix/modules/dbt/profile/service.py</code> <pre><code>def load_template(template_name: str = \"profiles.yml\") -&gt; tuple[str, DbtProfiles]:\n    \"\"\"Load and validate the bundled profile template.\n\n    Args:\n        template_name: Name of the template file\n\n    Returns:\n        Tuple of (raw template content, validated DbtProfiles)\n\n    Raises:\n        FileNotFoundError: If template doesn't exist\n        ValueError: If template is invalid YAML or doesn't match schema\n    \"\"\"\n    logger = get_logger()\n    logger.debug(\"Loading template: %s\", template_name)\n\n    content = get_template(template_name)\n    profiles = DbtProfiles.from_yaml(content)\n\n    logger.debug(\"Template validated successfully\")\n    return content, profiles\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.service.init_profile","title":"<code>init_profile(profile_path=None, *, force=False, template_name='profiles.yml')</code>","text":"<p>Initialize a dbt profile from template.</p> <p>Parameters:</p> Name Type Description Default <code>profile_path</code> <code>Path | None</code> <p>Target path for profiles.yml (uses default if None)</p> <code>None</code> <code>force</code> <code>bool</code> <p>Overwrite existing file if True</p> <code>False</code> <code>template_name</code> <code>str</code> <p>Name of template to use</p> <code>'profiles.yml'</code> <p>Returns:</p> Type Description <code>ProfileInitResult</code> <p>ProfileInitResult with success status and details</p> <p>Raises:</p> Type Description <code>ProfileExistsError</code> <p>If file exists and force is False</p> <code>FileNotFoundError</code> <p>If template doesn't exist</p> <code>ValueError</code> <p>If template validation fails</p> Source code in <code>src/brix/modules/dbt/profile/service.py</code> <pre><code>def init_profile(\n    profile_path: Path | None = None,\n    *,\n    force: bool = False,\n    template_name: str = \"profiles.yml\",\n) -&gt; ProfileInitResult:\n    \"\"\"Initialize a dbt profile from template.\n\n    Args:\n        profile_path: Target path for profiles.yml (uses default if None)\n        force: Overwrite existing file if True\n        template_name: Name of template to use\n\n    Returns:\n        ProfileInitResult with success status and details\n\n    Raises:\n        ProfileExistsError: If file exists and force is False\n        FileNotFoundError: If template doesn't exist\n        ValueError: If template validation fails\n    \"\"\"\n    logger = get_logger()\n\n    # Determine target path\n    target_path = profile_path or get_default_profile_path()\n    logger.debug(\"Target profile path: %s\", target_path)\n\n    # Check if file exists\n    if target_path.exists() and not force:\n        msg = f\"Profile already exists at {target_path}. Use --force to overwrite.\"\n        raise ProfileExistsError(msg)\n\n    # Load and validate template\n    content, _ = load_template(template_name)\n\n    # Ensure parent directory exists\n    target_path.parent.mkdir(parents=True, exist_ok=True)\n\n    # Determine action for result\n    action: Literal[\"created\", \"overwritten\", \"skipped\"] = \"overwritten\" if target_path.exists() else \"created\"\n\n    # Write profile\n    target_path.write_text(content)\n    logger.info(\"Profile %s at %s\", action, target_path)\n\n    return ProfileInitResult(\n        success=True,\n        path=target_path,\n        action=action,\n        message=f\"Profile {action} at {target_path}\",\n    )\n</code></pre>"},{"location":"api/modules/#profile-editor","title":"Profile Editor","text":""},{"location":"api/modules/#brix.modules.dbt.profile.editor","title":"<code>brix.modules.dbt.profile.editor</code>","text":"<p>Profile editing service for dbt profiles.yml.</p> <p>Provides CRUD operations for profiles and outputs with atomic save-on-change behavior.</p>"},{"location":"api/modules/#brix.modules.dbt.profile.editor.ProfileNotFoundError","title":"<code>ProfileNotFoundError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a profile does not exist.</p> Source code in <code>src/brix/modules/dbt/profile/editor.py</code> <pre><code>class ProfileNotFoundError(Exception):\n    \"\"\"Raised when a profile does not exist.\"\"\"\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.editor.OutputNotFoundError","title":"<code>OutputNotFoundError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when an output does not exist.</p> Source code in <code>src/brix/modules/dbt/profile/editor.py</code> <pre><code>class OutputNotFoundError(Exception):\n    \"\"\"Raised when an output does not exist.\"\"\"\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.editor.ProfileAlreadyExistsError","title":"<code>ProfileAlreadyExistsError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when attempting to create a profile that already exists.</p> Source code in <code>src/brix/modules/dbt/profile/editor.py</code> <pre><code>class ProfileAlreadyExistsError(Exception):\n    \"\"\"Raised when attempting to create a profile that already exists.\"\"\"\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.editor.OutputAlreadyExistsError","title":"<code>OutputAlreadyExistsError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when attempting to create an output that already exists.</p> Source code in <code>src/brix/modules/dbt/profile/editor.py</code> <pre><code>class OutputAlreadyExistsError(Exception):\n    \"\"\"Raised when attempting to create an output that already exists.\"\"\"\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.editor.load_profiles","title":"<code>load_profiles(path=None)</code>","text":"<p>Load profiles from disk.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | None</code> <p>Path to profiles.yml, uses default if None</p> <code>None</code> <p>Returns:</p> Type Description <code>DbtProfiles</code> <p>Parsed DbtProfiles instance</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> <code>ValueError</code> <p>If YAML is invalid</p> Source code in <code>src/brix/modules/dbt/profile/editor.py</code> <pre><code>def load_profiles(path: Path | None = None) -&gt; DbtProfiles:\n    \"\"\"Load profiles from disk.\n\n    Args:\n        path: Path to profiles.yml, uses default if None\n\n    Returns:\n        Parsed DbtProfiles instance\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n        ValueError: If YAML is invalid\n    \"\"\"\n    target_path = path or get_default_profile_path()\n    logger = get_logger()\n    logger.debug(\"Loading profiles from %s\", target_path)\n    return DbtProfiles.from_file(target_path)\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.editor.save_profiles","title":"<code>save_profiles(profiles, path=None)</code>","text":"<p>Validate and save profiles to disk.</p> <p>Parameters:</p> Name Type Description Default <code>profiles</code> <code>DbtProfiles</code> <p>DbtProfiles instance to save</p> required <code>path</code> <code>Path | None</code> <p>Path to profiles.yml, uses default if None</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If profiles fail validation</p> <code>IOError</code> <p>If file cannot be written</p> Source code in <code>src/brix/modules/dbt/profile/editor.py</code> <pre><code>def save_profiles(profiles: DbtProfiles, path: Path | None = None) -&gt; None:\n    \"\"\"Validate and save profiles to disk.\n\n    Args:\n        profiles: DbtProfiles instance to save\n        path: Path to profiles.yml, uses default if None\n\n    Raises:\n        ValueError: If profiles fail validation\n        IOError: If file cannot be written\n    \"\"\"\n    target_path = path or get_default_profile_path()\n    logger = get_logger()\n\n    # Validate by re-parsing (ensures YAML roundtrip is valid)\n    yaml_content = profiles.to_yaml()\n    DbtProfiles.from_yaml(yaml_content)\n\n    # Ensure parent directory exists\n    target_path.parent.mkdir(parents=True, exist_ok=True)\n\n    # Write to disk\n    target_path.write_text(yaml_content)\n    logger.debug(\"Saved profiles to %s\", target_path)\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.editor.get_profile_names","title":"<code>get_profile_names(profiles)</code>","text":"<p>Get list of profile names.</p> <p>Parameters:</p> Name Type Description Default <code>profiles</code> <code>DbtProfiles</code> <p>DbtProfiles instance</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of profile names</p> Source code in <code>src/brix/modules/dbt/profile/editor.py</code> <pre><code>def get_profile_names(profiles: DbtProfiles) -&gt; list[str]:\n    \"\"\"Get list of profile names.\n\n    Args:\n        profiles: DbtProfiles instance\n\n    Returns:\n        List of profile names\n    \"\"\"\n    return list(profiles.root.keys())\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.editor.get_output_names","title":"<code>get_output_names(profiles, profile_name)</code>","text":"<p>Get list of output names for a profile.</p> <p>Parameters:</p> Name Type Description Default <code>profiles</code> <code>DbtProfiles</code> <p>DbtProfiles instance</p> required <code>profile_name</code> <code>str</code> <p>Name of the profile</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of output names</p> <p>Raises:</p> Type Description <code>ProfileNotFoundError</code> <p>If profile doesn't exist</p> Source code in <code>src/brix/modules/dbt/profile/editor.py</code> <pre><code>def get_output_names(profiles: DbtProfiles, profile_name: str) -&gt; list[str]:\n    \"\"\"Get list of output names for a profile.\n\n    Args:\n        profiles: DbtProfiles instance\n        profile_name: Name of the profile\n\n    Returns:\n        List of output names\n\n    Raises:\n        ProfileNotFoundError: If profile doesn't exist\n    \"\"\"\n    if profile_name not in profiles.root:\n        msg = f\"Profile '{profile_name}' not found\"\n        raise ProfileNotFoundError(msg)\n    return list(profiles.root[profile_name].outputs.keys())\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.editor.add_profile","title":"<code>add_profile(profiles, name, target, output_name, output_config)</code>","text":"<p>Add a new profile.</p> <p>Parameters:</p> Name Type Description Default <code>profiles</code> <code>DbtProfiles</code> <p>DbtProfiles instance</p> required <code>name</code> <code>str</code> <p>Profile name</p> required <code>target</code> <code>str</code> <p>Default target name</p> required <code>output_name</code> <code>str</code> <p>Initial output name</p> required <code>output_config</code> <code>OutputConfig</code> <p>Initial output configuration (DuckDbOutput or DatabricksOutput)</p> required <p>Returns:</p> Type Description <code>DbtProfiles</code> <p>Updated DbtProfiles instance</p> <p>Raises:</p> Type Description <code>ProfileAlreadyExistsError</code> <p>If profile already exists</p> Source code in <code>src/brix/modules/dbt/profile/editor.py</code> <pre><code>def add_profile(\n    profiles: DbtProfiles,\n    name: str,\n    target: str,\n    output_name: str,\n    output_config: OutputConfig,\n) -&gt; DbtProfiles:\n    \"\"\"Add a new profile.\n\n    Args:\n        profiles: DbtProfiles instance\n        name: Profile name\n        target: Default target name\n        output_name: Initial output name\n        output_config: Initial output configuration (DuckDbOutput or DatabricksOutput)\n\n    Returns:\n        Updated DbtProfiles instance\n\n    Raises:\n        ProfileAlreadyExistsError: If profile already exists\n    \"\"\"\n    if name in profiles.root:\n        msg = f\"Profile '{name}' already exists\"\n        raise ProfileAlreadyExistsError(msg)\n\n    profiles.root[name] = ProfileTarget(\n        target=target,\n        outputs={output_name: output_config},\n    )\n    return profiles\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.editor.update_profile_target","title":"<code>update_profile_target(profiles, name, target)</code>","text":"<p>Update a profile's default target.</p> <p>Parameters:</p> Name Type Description Default <code>profiles</code> <code>DbtProfiles</code> <p>DbtProfiles instance</p> required <code>name</code> <code>str</code> <p>Profile name</p> required <code>target</code> <code>str</code> <p>New default target name</p> required <p>Returns:</p> Type Description <code>DbtProfiles</code> <p>Updated DbtProfiles instance</p> <p>Raises:</p> Type Description <code>ProfileNotFoundError</code> <p>If profile doesn't exist</p> Source code in <code>src/brix/modules/dbt/profile/editor.py</code> <pre><code>def update_profile_target(profiles: DbtProfiles, name: str, target: str) -&gt; DbtProfiles:\n    \"\"\"Update a profile's default target.\n\n    Args:\n        profiles: DbtProfiles instance\n        name: Profile name\n        target: New default target name\n\n    Returns:\n        Updated DbtProfiles instance\n\n    Raises:\n        ProfileNotFoundError: If profile doesn't exist\n    \"\"\"\n    if name not in profiles.root:\n        msg = f\"Profile '{name}' not found\"\n        raise ProfileNotFoundError(msg)\n\n    profiles.root[name].target = target\n    return profiles\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.editor.delete_profile","title":"<code>delete_profile(profiles, name)</code>","text":"<p>Delete a profile.</p> <p>Parameters:</p> Name Type Description Default <code>profiles</code> <code>DbtProfiles</code> <p>DbtProfiles instance</p> required <code>name</code> <code>str</code> <p>Profile name to delete</p> required <p>Returns:</p> Type Description <code>DbtProfiles</code> <p>Updated DbtProfiles instance</p> <p>Raises:</p> Type Description <code>ProfileNotFoundError</code> <p>If profile doesn't exist</p> Source code in <code>src/brix/modules/dbt/profile/editor.py</code> <pre><code>def delete_profile(profiles: DbtProfiles, name: str) -&gt; DbtProfiles:\n    \"\"\"Delete a profile.\n\n    Args:\n        profiles: DbtProfiles instance\n        name: Profile name to delete\n\n    Returns:\n        Updated DbtProfiles instance\n\n    Raises:\n        ProfileNotFoundError: If profile doesn't exist\n    \"\"\"\n    if name not in profiles.root:\n        msg = f\"Profile '{name}' not found\"\n        raise ProfileNotFoundError(msg)\n\n    del profiles.root[name]\n    return profiles\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.editor.add_output","title":"<code>add_output(profiles, profile_name, output_name, output_config)</code>","text":"<p>Add an output to a profile.</p> <p>Parameters:</p> Name Type Description Default <code>profiles</code> <code>DbtProfiles</code> <p>DbtProfiles instance</p> required <code>profile_name</code> <code>str</code> <p>Name of the profile</p> required <code>output_name</code> <code>str</code> <p>Name for the new output</p> required <code>output_config</code> <code>OutputConfig</code> <p>Output configuration (DuckDbOutput or DatabricksOutput)</p> required <p>Returns:</p> Type Description <code>DbtProfiles</code> <p>Updated DbtProfiles instance</p> <p>Raises:</p> Type Description <code>ProfileNotFoundError</code> <p>If profile doesn't exist</p> <code>OutputAlreadyExistsError</code> <p>If output already exists</p> Source code in <code>src/brix/modules/dbt/profile/editor.py</code> <pre><code>def add_output(\n    profiles: DbtProfiles,\n    profile_name: str,\n    output_name: str,\n    output_config: OutputConfig,\n) -&gt; DbtProfiles:\n    \"\"\"Add an output to a profile.\n\n    Args:\n        profiles: DbtProfiles instance\n        profile_name: Name of the profile\n        output_name: Name for the new output\n        output_config: Output configuration (DuckDbOutput or DatabricksOutput)\n\n    Returns:\n        Updated DbtProfiles instance\n\n    Raises:\n        ProfileNotFoundError: If profile doesn't exist\n        OutputAlreadyExistsError: If output already exists\n    \"\"\"\n    if profile_name not in profiles.root:\n        msg = f\"Profile '{profile_name}' not found\"\n        raise ProfileNotFoundError(msg)\n\n    if output_name in profiles.root[profile_name].outputs:\n        msg = f\"Output '{output_name}' already exists in profile '{profile_name}'\"\n        raise OutputAlreadyExistsError(msg)\n\n    profiles.root[profile_name].outputs[output_name] = output_config\n    return profiles\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.editor.update_output","title":"<code>update_output(profiles, profile_name, output_name, *, path=None, threads=None)</code>","text":"<p>Update a DuckDB output's configuration (legacy interface).</p> <p>For updating any adapter type, use update_output_fields() instead.</p> <p>Parameters:</p> Name Type Description Default <code>profiles</code> <code>DbtProfiles</code> <p>DbtProfiles instance</p> required <code>profile_name</code> <code>str</code> <p>Name of the profile</p> required <code>output_name</code> <code>str</code> <p>Name of the output</p> required <code>path</code> <code>str | None</code> <p>New path value (optional, DuckDB only)</p> <code>None</code> <code>threads</code> <code>int | None</code> <p>New threads value (optional)</p> <code>None</code> <p>Returns:</p> Type Description <code>DbtProfiles</code> <p>Updated DbtProfiles instance</p> <p>Raises:</p> Type Description <code>ProfileNotFoundError</code> <p>If profile doesn't exist</p> <code>OutputNotFoundError</code> <p>If output doesn't exist</p> <code>ValueError</code> <p>If threads is not a positive integer</p> Source code in <code>src/brix/modules/dbt/profile/editor.py</code> <pre><code>def update_output(\n    profiles: DbtProfiles,\n    profile_name: str,\n    output_name: str,\n    *,\n    path: str | None = None,\n    threads: int | None = None,\n) -&gt; DbtProfiles:\n    \"\"\"Update a DuckDB output's configuration (legacy interface).\n\n    For updating any adapter type, use update_output_fields() instead.\n\n    Args:\n        profiles: DbtProfiles instance\n        profile_name: Name of the profile\n        output_name: Name of the output\n        path: New path value (optional, DuckDB only)\n        threads: New threads value (optional)\n\n    Returns:\n        Updated DbtProfiles instance\n\n    Raises:\n        ProfileNotFoundError: If profile doesn't exist\n        OutputNotFoundError: If output doesn't exist\n        ValueError: If threads is not a positive integer\n    \"\"\"\n    updates: dict[str, Any] = {}\n    if path is not None:\n        updates[\"path\"] = path\n    if threads is not None:\n        updates[\"threads\"] = threads\n    return update_output_fields(profiles, profile_name, output_name, updates)\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.editor.update_output_fields","title":"<code>update_output_fields(profiles, profile_name, output_name, updates)</code>","text":"<p>Update an output's configuration with arbitrary field updates.</p> <p>Works with any adapter type (DuckDB, Databricks, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>profiles</code> <code>DbtProfiles</code> <p>DbtProfiles instance</p> required <code>profile_name</code> <code>str</code> <p>Name of the profile</p> required <code>output_name</code> <code>str</code> <p>Name of the output</p> required <code>updates</code> <code>dict[str, Any]</code> <p>Dictionary of field names to new values</p> required <p>Returns:</p> Type Description <code>DbtProfiles</code> <p>Updated DbtProfiles instance</p> <p>Raises:</p> Type Description <code>ProfileNotFoundError</code> <p>If profile doesn't exist</p> <code>OutputNotFoundError</code> <p>If output doesn't exist</p> <code>ValueError</code> <p>If validation fails (e.g., threads &lt; 1)</p> Source code in <code>src/brix/modules/dbt/profile/editor.py</code> <pre><code>def update_output_fields(\n    profiles: DbtProfiles,\n    profile_name: str,\n    output_name: str,\n    updates: dict[str, Any],\n) -&gt; DbtProfiles:\n    \"\"\"Update an output's configuration with arbitrary field updates.\n\n    Works with any adapter type (DuckDB, Databricks, etc.).\n\n    Args:\n        profiles: DbtProfiles instance\n        profile_name: Name of the profile\n        output_name: Name of the output\n        updates: Dictionary of field names to new values\n\n    Returns:\n        Updated DbtProfiles instance\n\n    Raises:\n        ProfileNotFoundError: If profile doesn't exist\n        OutputNotFoundError: If output doesn't exist\n        ValueError: If validation fails (e.g., threads &lt; 1)\n    \"\"\"\n    if profile_name not in profiles.root:\n        msg = f\"Profile '{profile_name}' not found\"\n        raise ProfileNotFoundError(msg)\n\n    if output_name not in profiles.root[profile_name].outputs:\n        msg = f\"Output '{output_name}' not found in profile '{profile_name}'\"\n        raise OutputNotFoundError(msg)\n\n    output = profiles.root[profile_name].outputs[output_name]\n\n    # Validate threads if being updated\n    if \"threads\" in updates:\n        threads = updates[\"threads\"]\n        if threads is not None and threads &lt; 1:\n            msg = \"threads must be a positive integer\"\n            raise ValueError(msg)\n\n    # Apply updates to the output\n    for field, value in updates.items():\n        if value is not None:\n            setattr(output, field, value)\n\n    return profiles\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.editor.delete_output","title":"<code>delete_output(profiles, profile_name, output_name)</code>","text":"<p>Delete an output from a profile.</p> <p>Parameters:</p> Name Type Description Default <code>profiles</code> <code>DbtProfiles</code> <p>DbtProfiles instance</p> required <code>profile_name</code> <code>str</code> <p>Name of the profile</p> required <code>output_name</code> <code>str</code> <p>Name of the output to delete</p> required <p>Returns:</p> Type Description <code>DbtProfiles</code> <p>Updated DbtProfiles instance</p> <p>Raises:</p> Type Description <code>ProfileNotFoundError</code> <p>If profile doesn't exist</p> <code>OutputNotFoundError</code> <p>If output doesn't exist</p> <code>ValueError</code> <p>If this is the last output in the profile</p> Source code in <code>src/brix/modules/dbt/profile/editor.py</code> <pre><code>def delete_output(\n    profiles: DbtProfiles,\n    profile_name: str,\n    output_name: str,\n) -&gt; DbtProfiles:\n    \"\"\"Delete an output from a profile.\n\n    Args:\n        profiles: DbtProfiles instance\n        profile_name: Name of the profile\n        output_name: Name of the output to delete\n\n    Returns:\n        Updated DbtProfiles instance\n\n    Raises:\n        ProfileNotFoundError: If profile doesn't exist\n        OutputNotFoundError: If output doesn't exist\n        ValueError: If this is the last output in the profile\n    \"\"\"\n    if profile_name not in profiles.root:\n        msg = f\"Profile '{profile_name}' not found\"\n        raise ProfileNotFoundError(msg)\n\n    if output_name not in profiles.root[profile_name].outputs:\n        msg = f\"Output '{output_name}' not found in profile '{profile_name}'\"\n        raise OutputNotFoundError(msg)\n\n    if len(profiles.root[profile_name].outputs) == 1:\n        msg = f\"Cannot delete last output from profile '{profile_name}'. Delete the profile instead.\"\n        raise ValueError(msg)\n\n    del profiles.root[profile_name].outputs[output_name]\n    return profiles\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.profile.editor.get_output","title":"<code>get_output(profiles, profile_name, output_name)</code>","text":"<p>Get an output configuration.</p> <p>Parameters:</p> Name Type Description Default <code>profiles</code> <code>DbtProfiles</code> <p>DbtProfiles instance</p> required <code>profile_name</code> <code>str</code> <p>Name of the profile</p> required <code>output_name</code> <code>str</code> <p>Name of the output</p> required <p>Returns:</p> Type Description <code>OutputConfig</code> <p>Output configuration (DuckDbOutput or DatabricksOutput)</p> <p>Raises:</p> Type Description <code>ProfileNotFoundError</code> <p>If profile doesn't exist</p> <code>OutputNotFoundError</code> <p>If output doesn't exist</p> Source code in <code>src/brix/modules/dbt/profile/editor.py</code> <pre><code>def get_output(profiles: DbtProfiles, profile_name: str, output_name: str) -&gt; OutputConfig:\n    \"\"\"Get an output configuration.\n\n    Args:\n        profiles: DbtProfiles instance\n        profile_name: Name of the profile\n        output_name: Name of the output\n\n    Returns:\n        Output configuration (DuckDbOutput or DatabricksOutput)\n\n    Raises:\n        ProfileNotFoundError: If profile doesn't exist\n        OutputNotFoundError: If output doesn't exist\n    \"\"\"\n    if profile_name not in profiles.root:\n        msg = f\"Profile '{profile_name}' not found\"\n        raise ProfileNotFoundError(msg)\n\n    if output_name not in profiles.root[profile_name].outputs:\n        msg = f\"Output '{output_name}' not found in profile '{profile_name}'\"\n        raise OutputNotFoundError(msg)\n\n    return profiles.root[profile_name].outputs[output_name]\n</code></pre>"},{"location":"api/modules/#project-service","title":"Project Service","text":""},{"location":"api/modules/#brix.modules.dbt.project.service","title":"<code>brix.modules.dbt.project.service</code>","text":"<p>Project management service for dbt projects.</p> <p>Handles project initialization, path resolution, and package version fetching.</p>"},{"location":"api/modules/#brix.modules.dbt.project.service.ProjectConfig","title":"<code>ProjectConfig</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Project configuration from environment variables.</p> Environment variables <p>BRIX_DBT_PROJECT_BASE_DIR: Default base directory for projects</p> Source code in <code>src/brix/modules/dbt/project/service.py</code> <pre><code>class ProjectConfig(BaseSettings):\n    \"\"\"Project configuration from environment variables.\n\n    Environment variables:\n        BRIX_DBT_PROJECT_BASE_DIR: Default base directory for projects\n    \"\"\"\n\n    model_config = SettingsConfigDict(\n        env_prefix=\"BRIX_DBT_PROJECT_\",\n        case_sensitive=False,\n    )\n\n    base_dir: Path | None = None\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.service.ProjectExistsError","title":"<code>ProjectExistsError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when project already exists and force is not set.</p> Source code in <code>src/brix/modules/dbt/project/service.py</code> <pre><code>class ProjectExistsError(Exception):\n    \"\"\"Raised when project already exists and force is not set.\"\"\"\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.service.ProjectInitResult","title":"<code>ProjectInitResult</code>  <code>dataclass</code>","text":"<p>Result of project initialization.</p> Source code in <code>src/brix/modules/dbt/project/service.py</code> <pre><code>@dataclass\nclass ProjectInitResult:\n    \"\"\"Result of project initialization.\"\"\"\n\n    success: bool\n    project_path: Path\n    action: Literal[\"created\", \"overwritten\", \"skipped\"]\n    message: str\n    files_created: list[str] = field(default_factory=list)\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.service.resolve_project_path","title":"<code>resolve_project_path(project_name, base_dir=None, team=None)</code>","text":"<p>Resolve the final project path from components.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Name of the project (becomes directory name)</p> required <code>base_dir</code> <code>Path | None</code> <p>Base directory (uses env var or cwd if None)</p> <code>None</code> <code>team</code> <code>str | None</code> <p>Optional team subdirectory</p> <code>None</code> <p>Returns:</p> Type Description <code>Path</code> <p>Resolved absolute path to project directory</p> Example <p>resolve_project_path(\"my_project\") PosixPath('/current/dir/my_project') resolve_project_path(\"my_project\", Path(\"assets/dbt_projects\"), \"analytics\") PosixPath('/current/dir/assets/dbt_projects/analytics/my_project')</p> Source code in <code>src/brix/modules/dbt/project/service.py</code> <pre><code>def resolve_project_path(\n    project_name: str,\n    base_dir: Path | None = None,\n    team: str | None = None,\n) -&gt; Path:\n    \"\"\"Resolve the final project path from components.\n\n    Args:\n        project_name: Name of the project (becomes directory name)\n        base_dir: Base directory (uses env var or cwd if None)\n        team: Optional team subdirectory\n\n    Returns:\n        Resolved absolute path to project directory\n\n    Example:\n        &gt;&gt;&gt; resolve_project_path(\"my_project\")\n        PosixPath('/current/dir/my_project')\n        &gt;&gt;&gt; resolve_project_path(\"my_project\", Path(\"assets/dbt_projects\"), \"analytics\")\n        PosixPath('/current/dir/assets/dbt_projects/analytics/my_project')\n    \"\"\"\n    config = ProjectConfig()\n    effective_base = base_dir or config.base_dir or Path.cwd()\n\n    # Make path absolute if relative\n    if not effective_base.is_absolute():\n        effective_base = Path.cwd() / effective_base\n\n    if team:\n        return effective_base / team / project_name\n    return effective_base / project_name\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.service.fetch_package_version","title":"<code>fetch_package_version(package)</code>","text":"<p>Fetch the latest version of a package from dbt Hub.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>Package name (e.g., \"dbt-labs/dbt_utils\")</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Version string (e.g., \"&gt;=1.3.0\") or None if fetch fails</p> Source code in <code>src/brix/modules/dbt/project/service.py</code> <pre><code>def fetch_package_version(package: str) -&gt; str | None:\n    \"\"\"Fetch the latest version of a package from dbt Hub.\n\n    Args:\n        package: Package name (e.g., \"dbt-labs/dbt_utils\")\n\n    Returns:\n        Version string (e.g., \"&gt;=1.3.0\") or None if fetch fails\n    \"\"\"\n    logger = get_logger()\n\n    try:\n        namespace, name = package.split(\"/\")\n        url = f\"https://hub.getdbt.com/api/v1/{namespace}/{name}/latest.json\"\n\n        logger.debug(\"Fetching package version from: %s\", url)\n\n        # Simple HTTP GET with timeout\n        with urllib.request.urlopen(url, timeout=5) as response:  # noqa: S310\n            import json\n\n            data = json.loads(response.read().decode())\n            version = data.get(\"version\")\n            if version:\n                logger.debug(\"Found version %s for %s\", version, package)\n                return f\"&gt;={version}\"\n    except Exception as e:\n        logger.debug(\"Failed to fetch version for %s: %s\", package, e)\n\n    return None\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.service.get_package_version","title":"<code>get_package_version(package)</code>","text":"<p>Get the version for a package, with fallback to defaults.</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>str</code> <p>Package name (e.g., \"dbt-labs/dbt_utils\")</p> required <p>Returns:</p> Type Description <code>str</code> <p>Version string (e.g., \"&gt;=1.0.0\")</p> Source code in <code>src/brix/modules/dbt/project/service.py</code> <pre><code>def get_package_version(package: str) -&gt; str:\n    \"\"\"Get the version for a package, with fallback to defaults.\n\n    Args:\n        package: Package name (e.g., \"dbt-labs/dbt_utils\")\n\n    Returns:\n        Version string (e.g., \"&gt;=1.0.0\")\n    \"\"\"\n    # Try to fetch from API\n    version = fetch_package_version(package)\n    if version:\n        return version\n\n    # Fall back to defaults\n    return DEFAULT_PACKAGE_VERSIONS.get(package, \"&gt;=0.1.0\")\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.service.fetch_package_versions_parallel","title":"<code>fetch_package_versions_parallel(pkg_names, max_workers=5)</code>","text":"<p>Fetch multiple package versions in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>pkg_names</code> <code>list[str]</code> <p>List of package names (e.g., [\"dbt-labs/dbt_utils\", \"elementary-data/elementary\"])</p> required <code>max_workers</code> <code>int</code> <p>Maximum number of concurrent threads</p> <code>5</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary mapping package names to version strings</p> Source code in <code>src/brix/modules/dbt/project/service.py</code> <pre><code>def fetch_package_versions_parallel(pkg_names: list[str], max_workers: int = 5) -&gt; dict[str, str]:\n    \"\"\"Fetch multiple package versions in parallel.\n\n    Args:\n        pkg_names: List of package names (e.g., [\"dbt-labs/dbt_utils\", \"elementary-data/elementary\"])\n        max_workers: Maximum number of concurrent threads\n\n    Returns:\n        Dictionary mapping package names to version strings\n    \"\"\"\n    from concurrent.futures import ThreadPoolExecutor, as_completed\n\n    logger = get_logger()\n    results: dict[str, str] = {}\n\n    logger.debug(\"Fetching %d package versions in parallel\", len(pkg_names))\n\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\n        futures = {executor.submit(get_package_version, pkg): pkg for pkg in pkg_names}\n        for future in as_completed(futures):\n            pkg_name = futures[future]\n            try:\n                results[pkg_name] = future.result()\n            except Exception as e:\n                logger.debug(\"Failed to fetch version for %s: %s\", pkg_name, e)\n                results[pkg_name] = DEFAULT_PACKAGE_VERSIONS.get(pkg_name, \"&gt;=0.1.0\")\n\n    return results\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.service.create_project_structure","title":"<code>create_project_structure(project_path, project_name, profile_name, *, packages=None, materialization=None, persist_docs=False, with_example=False)</code>","text":"<p>Create the dbt project directory structure and files.</p> <p>Parameters:</p> Name Type Description Default <code>project_path</code> <code>Path</code> <p>Path to create project in</p> required <code>project_name</code> <code>str</code> <p>Name of the project</p> required <code>profile_name</code> <code>str</code> <p>Name of the profile to use</p> required <code>packages</code> <code>list[HubPackage] | None</code> <p>List of packages to include (uses template default if None)</p> <code>None</code> <code>materialization</code> <code>str | None</code> <p>Default materialization (view, table, ephemeral)</p> <code>None</code> <code>persist_docs</code> <code>bool</code> <p>Whether to enable persist_docs for Databricks</p> <code>False</code> <code>with_example</code> <code>bool</code> <p>Whether to create example model</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of created file paths (relative to project_path)</p> Source code in <code>src/brix/modules/dbt/project/service.py</code> <pre><code>def create_project_structure(\n    project_path: Path,\n    project_name: str,\n    profile_name: str,\n    *,\n    packages: list[HubPackage] | None = None,\n    materialization: str | None = None,\n    persist_docs: bool = False,\n    with_example: bool = False,\n) -&gt; list[str]:\n    \"\"\"Create the dbt project directory structure and files.\n\n    Args:\n        project_path: Path to create project in\n        project_name: Name of the project\n        profile_name: Name of the profile to use\n        packages: List of packages to include (uses template default if None)\n        materialization: Default materialization (view, table, ephemeral)\n        persist_docs: Whether to enable persist_docs for Databricks\n        with_example: Whether to create example model\n\n    Returns:\n        List of created file paths (relative to project_path)\n    \"\"\"\n    logger = get_logger()\n    created_files: list[str] = []\n\n    # Create main directories\n    directories = [\"models\", \"seeds\", \"tests\", \"macros\", \"snapshots\", \"analyses\"]\n    for dir_name in directories:\n        dir_path = project_path / dir_name\n        dir_path.mkdir(parents=True, exist_ok=True)\n        # Add .gitkeep to empty directories\n        gitkeep = dir_path / \".gitkeep\"\n        gitkeep.touch()\n        created_files.append(f\"{dir_name}/.gitkeep\")\n        logger.debug(\"Created directory: %s\", dir_path)\n\n    # Build dbt_project.yml content\n    project_config: dict = {\n        \"name\": project_name,\n        \"version\": \"1.0.0\",\n        \"profile\": profile_name,\n        \"config-version\": 2,\n        \"model-paths\": [\"models\"],\n        \"analysis-paths\": [\"analyses\"],\n        \"test-paths\": [\"tests\"],\n        \"seed-paths\": [\"seeds\"],\n        \"macro-paths\": [\"macros\"],\n        \"snapshot-paths\": [\"snapshots\"],\n        \"clean-targets\": [\"target\", \"dbt_packages\"],\n    }\n\n    # Add models config if needed (materialization or persist_docs)\n    if materialization or persist_docs:\n        models_config: dict = {}\n        if materialization and materialization != \"view\":\n            models_config[\"+materialized\"] = materialization\n        if persist_docs:\n            models_config[\"+persist_docs\"] = {\"relation\": True, \"columns\": True}\n        if models_config:\n            project_config[\"models\"] = {project_name: models_config}\n\n    # Create dbt_project.yml\n    project = DbtProject(**project_config)\n    project_yml_path = project_path / \"dbt_project.yml\"\n    project_yml_path.write_text(project.to_yaml())\n    created_files.append(\"dbt_project.yml\")\n    logger.debug(\"Created: %s\", project_yml_path)\n\n    # Create packages.yml only if packages were specified\n    if packages is not None:\n        dbt_packages = DbtPackages(packages=list(packages))\n        packages_content = dbt_packages.to_yaml()\n        packages_yml_path = project_path / \"packages.yml\"\n        packages_yml_path.write_text(packages_content)\n        created_files.append(\"packages.yml\")\n        logger.debug(\"Created: %s\", packages_yml_path)\n\n    # Create .gitignore\n    gitignore_content = get_template(\"dbt_gitignore\")\n    gitignore_path = project_path / \".gitignore\"\n    gitignore_path.write_text(gitignore_content)\n    created_files.append(\".gitignore\")\n    logger.debug(\"Created: %s\", gitignore_path)\n\n    # Create example model if requested\n    if with_example:\n        example_dir = project_path / \"models\" / \"example\"\n        example_dir.mkdir(parents=True, exist_ok=True)\n\n        # Create example model SQL\n        model_content = get_template(\"example_model.sql\")\n        model_path = example_dir / \"my_first_model.sql\"\n        model_path.write_text(model_content)\n        created_files.append(\"models/example/my_first_model.sql\")\n        logger.debug(\"Created: %s\", model_path)\n\n        # Create example schema YAML\n        schema_content = get_template(\"example_schema.yml\")\n        schema_path = example_dir / \"schema.yml\"\n        schema_path.write_text(schema_content)\n        created_files.append(\"models/example/schema.yml\")\n        logger.debug(\"Created: %s\", schema_path)\n\n    return created_files\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.service.init_project","title":"<code>init_project(project_name, profile_name, base_dir=None, team=None, *, packages=None, materialization=None, persist_docs=False, with_example=False, force=False)</code>","text":"<p>Initialize a new dbt project.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>Name of the project</p> required <code>profile_name</code> <code>str</code> <p>Name of the profile to use</p> required <code>base_dir</code> <code>Path | None</code> <p>Base directory for project (uses env var or cwd if None)</p> <code>None</code> <code>team</code> <code>str | None</code> <p>Optional team subdirectory</p> <code>None</code> <code>packages</code> <code>list[HubPackage] | None</code> <p>List of packages to include</p> <code>None</code> <code>materialization</code> <code>str | None</code> <p>Default materialization (view, table, ephemeral)</p> <code>None</code> <code>persist_docs</code> <code>bool</code> <p>Whether to enable persist_docs for Databricks</p> <code>False</code> <code>with_example</code> <code>bool</code> <p>Whether to create example model</p> <code>False</code> <code>force</code> <code>bool</code> <p>Overwrite existing project if True</p> <code>False</code> <p>Returns:</p> Type Description <code>ProjectInitResult</code> <p>ProjectInitResult with success status and details</p> <p>Raises:</p> Type Description <code>ProjectExistsError</code> <p>If project exists and force is False</p> <code>ProjectNameError</code> <p>If project name is invalid</p> Source code in <code>src/brix/modules/dbt/project/service.py</code> <pre><code>def init_project(\n    project_name: str,\n    profile_name: str,\n    base_dir: Path | None = None,\n    team: str | None = None,\n    *,\n    packages: list[HubPackage] | None = None,\n    materialization: str | None = None,\n    persist_docs: bool = False,\n    with_example: bool = False,\n    force: bool = False,\n) -&gt; ProjectInitResult:\n    \"\"\"Initialize a new dbt project.\n\n    Args:\n        project_name: Name of the project\n        profile_name: Name of the profile to use\n        base_dir: Base directory for project (uses env var or cwd if None)\n        team: Optional team subdirectory\n        packages: List of packages to include\n        materialization: Default materialization (view, table, ephemeral)\n        persist_docs: Whether to enable persist_docs for Databricks\n        with_example: Whether to create example model\n        force: Overwrite existing project if True\n\n    Returns:\n        ProjectInitResult with success status and details\n\n    Raises:\n        ProjectExistsError: If project exists and force is False\n        ProjectNameError: If project name is invalid\n    \"\"\"\n    logger = get_logger()\n\n    # Validate project name\n    validate_project_name(project_name)\n\n    # Resolve project path\n    project_path = resolve_project_path(project_name, base_dir, team)\n    logger.debug(\"Project path: %s\", project_path)\n\n    # Check if project exists\n    dbt_project_yml = project_path / \"dbt_project.yml\"\n    if dbt_project_yml.exists() and not force:\n        msg = f\"Project already exists at {project_path}. Use --force to overwrite.\"\n        raise ProjectExistsError(msg)\n\n    # Determine action\n    action: Literal[\"created\", \"overwritten\", \"skipped\"] = \"overwritten\" if dbt_project_yml.exists() else \"created\"\n\n    # Create project directory if needed\n    project_path.mkdir(parents=True, exist_ok=True)\n\n    # Create project structure\n    files_created = create_project_structure(\n        project_path=project_path,\n        project_name=project_name,\n        profile_name=profile_name,\n        packages=packages,\n        materialization=materialization,\n        persist_docs=persist_docs,\n        with_example=with_example,\n    )\n\n    logger.info(\"Project %s at %s\", action, project_path)\n\n    return ProjectInitResult(\n        success=True,\n        project_path=project_path,\n        action=action,\n        message=f\"Project {action} at {project_path}\",\n        files_created=files_created,\n    )\n</code></pre>"},{"location":"api/modules/#project-editor","title":"Project Editor","text":""},{"location":"api/modules/#brix.modules.dbt.project.editor","title":"<code>brix.modules.dbt.project.editor</code>","text":"<p>Project editing service for dbt projects.</p> <p>Provides CRUD operations for dbt_project.yml and packages.yml with atomic save-on-change behavior.</p>"},{"location":"api/modules/#brix.modules.dbt.project.editor.ProjectNotFoundError","title":"<code>ProjectNotFoundError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when dbt_project.yml does not exist.</p> Source code in <code>src/brix/modules/dbt/project/editor.py</code> <pre><code>class ProjectNotFoundError(Exception):\n    \"\"\"Raised when dbt_project.yml does not exist.\"\"\"\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.editor.PackageNotFoundError","title":"<code>PackageNotFoundError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a package does not exist in packages.yml.</p> Source code in <code>src/brix/modules/dbt/project/editor.py</code> <pre><code>class PackageNotFoundError(Exception):\n    \"\"\"Raised when a package does not exist in packages.yml.\"\"\"\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.editor.PackageAlreadyExistsError","title":"<code>PackageAlreadyExistsError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when attempting to add a duplicate package.</p> Source code in <code>src/brix/modules/dbt/project/editor.py</code> <pre><code>class PackageAlreadyExistsError(Exception):\n    \"\"\"Raised when attempting to add a duplicate package.\"\"\"\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.editor.InvalidFieldError","title":"<code>InvalidFieldError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when attempting to edit an invalid or restricted field.</p> Source code in <code>src/brix/modules/dbt/project/editor.py</code> <pre><code>class InvalidFieldError(Exception):\n    \"\"\"Raised when attempting to edit an invalid or restricted field.\"\"\"\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.editor.load_project","title":"<code>load_project(path)</code>","text":"<p>Load dbt_project.yml from disk.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to dbt_project.yml file</p> required <p>Returns:</p> Type Description <code>DbtProject</code> <p>Parsed DbtProject instance</p> <p>Raises:</p> Type Description <code>ProjectNotFoundError</code> <p>If file doesn't exist</p> <code>ValueError</code> <p>If YAML is invalid</p> Source code in <code>src/brix/modules/dbt/project/editor.py</code> <pre><code>def load_project(path: Path) -&gt; DbtProject:\n    \"\"\"Load dbt_project.yml from disk.\n\n    Args:\n        path: Path to dbt_project.yml file\n\n    Returns:\n        Parsed DbtProject instance\n\n    Raises:\n        ProjectNotFoundError: If file doesn't exist\n        ValueError: If YAML is invalid\n    \"\"\"\n    logger = get_logger()\n\n    if not path.exists():\n        msg = f\"Project file not found: {path}\"\n        raise ProjectNotFoundError(msg)\n\n    logger.debug(\"Loading project from %s\", path)\n    return DbtProject.from_file(path)\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.editor.save_project","title":"<code>save_project(project, path)</code>","text":"<p>Validate and save dbt_project.yml to disk.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>DbtProject</code> <p>DbtProject instance to save</p> required <code>path</code> <code>Path</code> <p>Path to dbt_project.yml file</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If project fails validation</p> <code>IOError</code> <p>If file cannot be written</p> Source code in <code>src/brix/modules/dbt/project/editor.py</code> <pre><code>def save_project(project: DbtProject, path: Path) -&gt; None:\n    \"\"\"Validate and save dbt_project.yml to disk.\n\n    Args:\n        project: DbtProject instance to save\n        path: Path to dbt_project.yml file\n\n    Raises:\n        ValueError: If project fails validation\n        IOError: If file cannot be written\n    \"\"\"\n    logger = get_logger()\n\n    # Validate by re-parsing (ensures YAML roundtrip is valid)\n    yaml_content = project.to_yaml()\n    DbtProject.from_yaml(yaml_content)\n\n    # Ensure parent directory exists\n    path.parent.mkdir(parents=True, exist_ok=True)\n\n    # Write to disk\n    path.write_text(yaml_content)\n    logger.debug(\"Saved project to %s\", path)\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.editor.load_packages","title":"<code>load_packages(project_dir)</code>","text":"<p>Load packages.yml from project directory.</p> <p>Parameters:</p> Name Type Description Default <code>project_dir</code> <code>Path</code> <p>Path to project directory (or dbt_project.yml file)</p> required <p>Returns:</p> Type Description <code>DbtPackages</code> <p>Parsed DbtPackages instance (empty if file doesn't exist)</p> Source code in <code>src/brix/modules/dbt/project/editor.py</code> <pre><code>def load_packages(project_dir: Path) -&gt; DbtPackages:\n    \"\"\"Load packages.yml from project directory.\n\n    Args:\n        project_dir: Path to project directory (or dbt_project.yml file)\n\n    Returns:\n        Parsed DbtPackages instance (empty if file doesn't exist)\n    \"\"\"\n    logger = get_logger()\n\n    # Handle both directory and file paths\n    if project_dir.name == \"dbt_project.yml\":\n        project_dir = project_dir.parent\n\n    packages_path = project_dir / \"packages.yml\"\n\n    if not packages_path.exists():\n        logger.debug(\"No packages.yml found at %s, returning empty\", packages_path)\n        return DbtPackages(packages=[])\n\n    logger.debug(\"Loading packages from %s\", packages_path)\n    return DbtPackages.from_file(packages_path)\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.editor.save_packages","title":"<code>save_packages(packages, project_dir)</code>","text":"<p>Save packages.yml to project directory.</p> <p>Parameters:</p> Name Type Description Default <code>packages</code> <code>DbtPackages</code> <p>DbtPackages instance to save</p> required <code>project_dir</code> <code>Path</code> <p>Path to project directory (or dbt_project.yml file)</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If packages fail validation</p> <code>IOError</code> <p>If file cannot be written</p> Source code in <code>src/brix/modules/dbt/project/editor.py</code> <pre><code>def save_packages(packages: DbtPackages, project_dir: Path) -&gt; None:\n    \"\"\"Save packages.yml to project directory.\n\n    Args:\n        packages: DbtPackages instance to save\n        project_dir: Path to project directory (or dbt_project.yml file)\n\n    Raises:\n        ValueError: If packages fail validation\n        IOError: If file cannot be written\n    \"\"\"\n    logger = get_logger()\n\n    # Handle both directory and file paths\n    if project_dir.name == \"dbt_project.yml\":\n        project_dir = project_dir.parent\n\n    packages_path = project_dir / \"packages.yml\"\n\n    # Validate by re-parsing\n    yaml_content = packages.to_yaml()\n    DbtPackages.from_yaml(yaml_content)\n\n    # Write to disk\n    packages_path.write_text(yaml_content)\n    logger.debug(\"Saved packages to %s\", packages_path)\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.editor.update_project_field","title":"<code>update_project_field(project, field, value)</code>","text":"<p>Update a single project field.</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>DbtProject</code> <p>DbtProject instance</p> required <code>field</code> <code>str</code> <p>Field name to update</p> required <code>value</code> <code>str | None</code> <p>New value for the field</p> required <p>Returns:</p> Type Description <code>DbtProject</code> <p>Updated DbtProject instance</p> <p>Raises:</p> Type Description <code>InvalidFieldError</code> <p>If field is not editable</p> <code>ValueError</code> <p>If value fails validation (e.g., invalid project name)</p> Source code in <code>src/brix/modules/dbt/project/editor.py</code> <pre><code>def update_project_field(\n    project: DbtProject,\n    field: str,\n    value: str | None,\n) -&gt; DbtProject:\n    \"\"\"Update a single project field.\n\n    Args:\n        project: DbtProject instance\n        field: Field name to update\n        value: New value for the field\n\n    Returns:\n        Updated DbtProject instance\n\n    Raises:\n        InvalidFieldError: If field is not editable\n        ValueError: If value fails validation (e.g., invalid project name)\n    \"\"\"\n    # Normalize field name (convert dashes to underscores)\n    field = field.replace(\"-\", \"_\")\n\n    if field not in EDITABLE_FIELDS:\n        msg = f\"Field '{field}' is not editable. Editable fields: {', '.join(sorted(EDITABLE_FIELDS))}\"\n        raise InvalidFieldError(msg)\n\n    # Special validation for project name\n    if field == \"name\" and value is not None:\n        validate_project_name(value)\n\n    setattr(project, field, value)\n    return project\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.editor.update_path_field","title":"<code>update_path_field(project, field, action, value)</code>","text":"<p>Update a path list field (add/remove/set).</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>DbtProject</code> <p>DbtProject instance</p> required <code>field</code> <code>str</code> <p>Field name (model_paths, seed_paths, etc.)</p> required <code>action</code> <code>Literal['add', 'remove', 'set']</code> <p>Operation to perform</p> required <code>value</code> <code>str | list[str]</code> <p>Path(s) to add/remove, or full list for \"set\"</p> required <p>Returns:</p> Type Description <code>DbtProject</code> <p>Updated DbtProject instance</p> <p>Raises:</p> Type Description <code>InvalidFieldError</code> <p>If field is not a path field</p> <code>ValueError</code> <p>If action is invalid or path not found for remove</p> Source code in <code>src/brix/modules/dbt/project/editor.py</code> <pre><code>def update_path_field(\n    project: DbtProject,\n    field: str,\n    action: Literal[\"add\", \"remove\", \"set\"],\n    value: str | list[str],\n) -&gt; DbtProject:\n    \"\"\"Update a path list field (add/remove/set).\n\n    Args:\n        project: DbtProject instance\n        field: Field name (model_paths, seed_paths, etc.)\n        action: Operation to perform\n        value: Path(s) to add/remove, or full list for \"set\"\n\n    Returns:\n        Updated DbtProject instance\n\n    Raises:\n        InvalidFieldError: If field is not a path field\n        ValueError: If action is invalid or path not found for remove\n    \"\"\"\n    # Normalize field name (convert dashes to underscores)\n    field = field.replace(\"-\", \"_\")\n\n    if field not in PATH_FIELDS:\n        msg = f\"Field '{field}' is not a path field. Path fields: {', '.join(sorted(PATH_FIELDS))}\"\n        raise InvalidFieldError(msg)\n\n    current_paths: list[str] = getattr(project, field, [])\n\n    if action == \"add\":\n        path_to_add = value if isinstance(value, str) else value[0]\n        if path_to_add not in current_paths:\n            current_paths.append(path_to_add)\n    elif action == \"remove\":\n        path_to_remove = value if isinstance(value, str) else value[0]\n        if path_to_remove not in current_paths:\n            msg = f\"Path '{path_to_remove}' not found in {field}\"\n            raise ValueError(msg)\n        current_paths.remove(path_to_remove)\n    elif action == \"set\":\n        current_paths = list(value) if isinstance(value, list) else [value]\n    else:\n        msg = f\"Invalid action: {action}. Must be 'add', 'remove', or 'set'\"\n        raise ValueError(msg)\n\n    setattr(project, field, current_paths)\n    return project\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.editor.get_package_identifiers","title":"<code>get_package_identifiers(packages)</code>","text":"<p>Get list of all package identifiers for display.</p> <p>Parameters:</p> Name Type Description Default <code>packages</code> <code>DbtPackages</code> <p>DbtPackages instance</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of package identifiers</p> Source code in <code>src/brix/modules/dbt/project/editor.py</code> <pre><code>def get_package_identifiers(packages: DbtPackages) -&gt; list[str]:\n    \"\"\"Get list of all package identifiers for display.\n\n    Args:\n        packages: DbtPackages instance\n\n    Returns:\n        List of package identifiers\n    \"\"\"\n    return [_get_package_identifier(pkg) for pkg in packages.packages]\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.editor.find_package_index","title":"<code>find_package_index(packages, identifier)</code>","text":"<p>Find package index by identifier.</p> <p>Parameters:</p> Name Type Description Default <code>packages</code> <code>DbtPackages</code> <p>DbtPackages instance</p> required <code>identifier</code> <code>str</code> <p>Package name (hub), git URL, or local path</p> required <p>Returns:</p> Type Description <code>int | None</code> <p>Index of package or None if not found</p> Source code in <code>src/brix/modules/dbt/project/editor.py</code> <pre><code>def find_package_index(packages: DbtPackages, identifier: str) -&gt; int | None:\n    \"\"\"Find package index by identifier.\n\n    Args:\n        packages: DbtPackages instance\n        identifier: Package name (hub), git URL, or local path\n\n    Returns:\n        Index of package or None if not found\n    \"\"\"\n    for i, pkg in enumerate(packages.packages):\n        if _get_package_identifier(pkg) == identifier:\n            return i\n    return None\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.editor.has_package","title":"<code>has_package(packages, identifier)</code>","text":"<p>Check if package exists.</p> <p>Parameters:</p> Name Type Description Default <code>packages</code> <code>DbtPackages</code> <p>DbtPackages instance</p> required <code>identifier</code> <code>str</code> <p>Package identifier</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if package exists</p> Source code in <code>src/brix/modules/dbt/project/editor.py</code> <pre><code>def has_package(packages: DbtPackages, identifier: str) -&gt; bool:\n    \"\"\"Check if package exists.\n\n    Args:\n        packages: DbtPackages instance\n        identifier: Package identifier\n\n    Returns:\n        True if package exists\n    \"\"\"\n    return find_package_index(packages, identifier) is not None\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.editor.add_hub_package","title":"<code>add_hub_package(packages, package_name, version)</code>","text":"<p>Add a hub package.</p> <p>Parameters:</p> Name Type Description Default <code>packages</code> <code>DbtPackages</code> <p>DbtPackages instance</p> required <code>package_name</code> <code>str</code> <p>Package name (e.g., \"dbt-labs/dbt_utils\")</p> required <code>version</code> <code>str</code> <p>Version specifier (e.g., \"&gt;=1.0.0\")</p> required <p>Returns:</p> Type Description <code>DbtPackages</code> <p>Updated DbtPackages instance</p> <p>Raises:</p> Type Description <code>PackageAlreadyExistsError</code> <p>If package already exists</p> Source code in <code>src/brix/modules/dbt/project/editor.py</code> <pre><code>def add_hub_package(\n    packages: DbtPackages,\n    package_name: str,\n    version: str,\n) -&gt; DbtPackages:\n    \"\"\"Add a hub package.\n\n    Args:\n        packages: DbtPackages instance\n        package_name: Package name (e.g., \"dbt-labs/dbt_utils\")\n        version: Version specifier (e.g., \"&gt;=1.0.0\")\n\n    Returns:\n        Updated DbtPackages instance\n\n    Raises:\n        PackageAlreadyExistsError: If package already exists\n    \"\"\"\n    if has_package(packages, package_name):\n        msg = f\"Package '{package_name}' already exists\"\n        raise PackageAlreadyExistsError(msg)\n\n    packages.packages.append(HubPackage(package=package_name, version=version))\n    return packages\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.editor.add_git_package","title":"<code>add_git_package(packages, git_url, revision, subdirectory=None)</code>","text":"<p>Add a git package.</p> <p>Parameters:</p> Name Type Description Default <code>packages</code> <code>DbtPackages</code> <p>DbtPackages instance</p> required <code>git_url</code> <code>str</code> <p>Git repository URL</p> required <code>revision</code> <code>str</code> <p>Branch, tag, or commit hash</p> required <code>subdirectory</code> <code>str | None</code> <p>Optional subdirectory within repo</p> <code>None</code> <p>Returns:</p> Type Description <code>DbtPackages</code> <p>Updated DbtPackages instance</p> <p>Raises:</p> Type Description <code>PackageAlreadyExistsError</code> <p>If package already exists</p> Source code in <code>src/brix/modules/dbt/project/editor.py</code> <pre><code>def add_git_package(\n    packages: DbtPackages,\n    git_url: str,\n    revision: str,\n    subdirectory: str | None = None,\n) -&gt; DbtPackages:\n    \"\"\"Add a git package.\n\n    Args:\n        packages: DbtPackages instance\n        git_url: Git repository URL\n        revision: Branch, tag, or commit hash\n        subdirectory: Optional subdirectory within repo\n\n    Returns:\n        Updated DbtPackages instance\n\n    Raises:\n        PackageAlreadyExistsError: If package already exists\n    \"\"\"\n    if has_package(packages, git_url):\n        msg = f\"Git package '{git_url}' already exists\"\n        raise PackageAlreadyExistsError(msg)\n\n    packages.packages.append(GitPackage(git=git_url, revision=revision, subdirectory=subdirectory))\n    return packages\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.editor.add_local_package","title":"<code>add_local_package(packages, local_path)</code>","text":"<p>Add a local package.</p> <p>Parameters:</p> Name Type Description Default <code>packages</code> <code>DbtPackages</code> <p>DbtPackages instance</p> required <code>local_path</code> <code>str</code> <p>Local filesystem path</p> required <p>Returns:</p> Type Description <code>DbtPackages</code> <p>Updated DbtPackages instance</p> <p>Raises:</p> Type Description <code>PackageAlreadyExistsError</code> <p>If package already exists</p> Source code in <code>src/brix/modules/dbt/project/editor.py</code> <pre><code>def add_local_package(\n    packages: DbtPackages,\n    local_path: str,\n) -&gt; DbtPackages:\n    \"\"\"Add a local package.\n\n    Args:\n        packages: DbtPackages instance\n        local_path: Local filesystem path\n\n    Returns:\n        Updated DbtPackages instance\n\n    Raises:\n        PackageAlreadyExistsError: If package already exists\n    \"\"\"\n    if has_package(packages, local_path):\n        msg = f\"Local package '{local_path}' already exists\"\n        raise PackageAlreadyExistsError(msg)\n\n    packages.packages.append(LocalPackage(local=local_path))\n    return packages\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.editor.remove_package","title":"<code>remove_package(packages, identifier)</code>","text":"<p>Remove a package by its identifier.</p> <p>Parameters:</p> Name Type Description Default <code>packages</code> <code>DbtPackages</code> <p>DbtPackages instance</p> required <code>identifier</code> <code>str</code> <p>Package name, git URL, or local path</p> required <p>Returns:</p> Type Description <code>DbtPackages</code> <p>Updated DbtPackages instance</p> <p>Raises:</p> Type Description <code>PackageNotFoundError</code> <p>If package not found</p> Source code in <code>src/brix/modules/dbt/project/editor.py</code> <pre><code>def remove_package(\n    packages: DbtPackages,\n    identifier: str,\n) -&gt; DbtPackages:\n    \"\"\"Remove a package by its identifier.\n\n    Args:\n        packages: DbtPackages instance\n        identifier: Package name, git URL, or local path\n\n    Returns:\n        Updated DbtPackages instance\n\n    Raises:\n        PackageNotFoundError: If package not found\n    \"\"\"\n    index = find_package_index(packages, identifier)\n    if index is None:\n        msg = f\"Package '{identifier}' not found\"\n        raise PackageNotFoundError(msg)\n\n    packages.packages.pop(index)\n    return packages\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.editor.update_package_version","title":"<code>update_package_version(packages, package_name, new_version)</code>","text":"<p>Update a hub package version.</p> <p>Parameters:</p> Name Type Description Default <code>packages</code> <code>DbtPackages</code> <p>DbtPackages instance</p> required <code>package_name</code> <code>str</code> <p>Package name (must be a hub package)</p> required <code>new_version</code> <code>str</code> <p>New version specifier</p> required <p>Returns:</p> Type Description <code>DbtPackages</code> <p>Updated DbtPackages instance</p> <p>Raises:</p> Type Description <code>PackageNotFoundError</code> <p>If package not found</p> <code>ValueError</code> <p>If package is not a hub package</p> Source code in <code>src/brix/modules/dbt/project/editor.py</code> <pre><code>def update_package_version(\n    packages: DbtPackages,\n    package_name: str,\n    new_version: str,\n) -&gt; DbtPackages:\n    \"\"\"Update a hub package version.\n\n    Args:\n        packages: DbtPackages instance\n        package_name: Package name (must be a hub package)\n        new_version: New version specifier\n\n    Returns:\n        Updated DbtPackages instance\n\n    Raises:\n        PackageNotFoundError: If package not found\n        ValueError: If package is not a hub package\n    \"\"\"\n    index = find_package_index(packages, package_name)\n    if index is None:\n        msg = f\"Package '{package_name}' not found\"\n        raise PackageNotFoundError(msg)\n\n    pkg = packages.packages[index]\n    if not isinstance(pkg, HubPackage):\n        msg = f\"Package '{package_name}' is not a hub package, cannot update version\"\n        raise ValueError(msg)\n\n    pkg.version = new_version\n    return packages\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.editor.get_package_display_info","title":"<code>get_package_display_info(packages)</code>","text":"<p>Get package information for display.</p> <p>Parameters:</p> Name Type Description Default <code>packages</code> <code>DbtPackages</code> <p>DbtPackages instance</p> required <p>Returns:</p> Type Description <code>list[tuple[str, str]]</code> <p>List of (identifier, type_info) tuples for display</p> Source code in <code>src/brix/modules/dbt/project/editor.py</code> <pre><code>def get_package_display_info(packages: DbtPackages) -&gt; list[tuple[str, str]]:\n    \"\"\"Get package information for display.\n\n    Args:\n        packages: DbtPackages instance\n\n    Returns:\n        List of (identifier, type_info) tuples for display\n    \"\"\"\n    result: list[tuple[str, str]] = []\n    for pkg in packages.packages:\n        if isinstance(pkg, HubPackage):\n            result.append((pkg.package, f\"hub: {pkg.version}\"))\n        elif isinstance(pkg, GitPackage):\n            info = f\"git: {pkg.revision}\"\n            if pkg.subdirectory:\n                info += f\" ({pkg.subdirectory})\"\n            result.append((pkg.git, info))\n        else:\n            result.append((pkg.local, \"local\"))\n    return result\n</code></pre>"},{"location":"api/modules/#project-finder","title":"Project Finder","text":""},{"location":"api/modules/#brix.modules.dbt.project.finder","title":"<code>brix.modules.dbt.project.finder</code>","text":"<p>Project discovery service for dbt projects.</p> <p>Provides functions to find dbt_project.yml files in a directory tree with interactive fuzzy selection support.</p>"},{"location":"api/modules/#brix.modules.dbt.project.finder.get_search_root","title":"<code>get_search_root()</code>","text":"<p>Get the search root directory.</p> <p>Returns git repository root if in a git repo, otherwise current working directory.</p> <p>Returns:</p> Type Description <code>Path</code> <p>Path to search root directory</p> Source code in <code>src/brix/modules/dbt/project/finder.py</code> <pre><code>def get_search_root() -&gt; Path:\n    \"\"\"Get the search root directory.\n\n    Returns git repository root if in a git repo, otherwise current working directory.\n\n    Returns:\n        Path to search root directory\n    \"\"\"\n    logger = get_logger()\n\n    try:\n        result = subprocess.run(\n            [\"git\", \"rev-parse\", \"--show-toplevel\"],  # noqa: S607\n            capture_output=True,\n            text=True,\n            check=True,\n        )\n        git_root = Path(result.stdout.strip())\n        logger.debug(\"Using git root as search root: %s\", git_root)\n        return git_root\n    except (subprocess.CalledProcessError, FileNotFoundError):\n        cwd = Path.cwd()\n        logger.debug(\"Not in git repo, using cwd as search root: %s\", cwd)\n        return cwd\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.finder.find_dbt_projects","title":"<code>find_dbt_projects(root=None, max_depth=10)</code>","text":"<p>Find all dbt_project.yml files under root directory.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Path | None</code> <p>Search root (uses get_search_root() if None)</p> <code>None</code> <code>max_depth</code> <code>int</code> <p>Maximum directory depth to search (default 10)</p> <code>10</code> <p>Returns:</p> Type Description <code>list[Path]</code> <p>List of absolute paths to dbt_project.yml files, sorted by path</p> Source code in <code>src/brix/modules/dbt/project/finder.py</code> <pre><code>def find_dbt_projects(\n    root: Path | None = None,\n    max_depth: int = 10,\n) -&gt; list[Path]:\n    \"\"\"Find all dbt_project.yml files under root directory.\n\n    Args:\n        root: Search root (uses get_search_root() if None)\n        max_depth: Maximum directory depth to search (default 10)\n\n    Returns:\n        List of absolute paths to dbt_project.yml files, sorted by path\n    \"\"\"\n    logger = get_logger()\n    search_root = root or get_search_root()\n\n    if not search_root.exists():\n        logger.warning(\"Search root does not exist: %s\", search_root)\n        return []\n\n    projects: list[Path] = []\n\n    # Use glob to find all dbt_project.yml files\n    for project_file in search_root.glob(\"**/dbt_project.yml\"):\n        # Check depth\n        try:\n            relative = project_file.relative_to(search_root)\n            depth = len(relative.parts) - 1  # Subtract 1 for the filename itself\n            if depth &gt; max_depth:\n                continue\n        except ValueError:\n            continue\n\n        # Check exclusions\n        if _should_exclude(project_file):\n            logger.debug(\"Excluding project in excluded directory: %s\", project_file)\n            continue\n\n        projects.append(project_file.resolve())\n        logger.debug(\"Found dbt project: %s\", project_file)\n\n    # Sort by path for consistent ordering\n    projects.sort()\n    logger.debug(\"Found %d dbt projects\", len(projects))\n\n    return projects\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.finder.prompt_select_project","title":"<code>prompt_select_project(projects, search_root=None)</code>","text":"<p>Interactive project selection with fuzzy autocomplete.</p> <p>Parameters:</p> Name Type Description Default <code>projects</code> <code>list[Path]</code> <p>List of dbt_project.yml paths</p> required <code>search_root</code> <code>Path | None</code> <p>Root directory for relative path display (uses get_search_root() if None)</p> <code>None</code> <p>Returns:</p> Type Description <code>Path | None</code> <p>Selected project path, or None if cancelled</p> Source code in <code>src/brix/modules/dbt/project/finder.py</code> <pre><code>def prompt_select_project(\n    projects: list[Path],\n    search_root: Path | None = None,\n) -&gt; Path | None:\n    \"\"\"Interactive project selection with fuzzy autocomplete.\n\n    Args:\n        projects: List of dbt_project.yml paths\n        search_root: Root directory for relative path display (uses get_search_root() if None)\n\n    Returns:\n        Selected project path, or None if cancelled\n    \"\"\"\n    if not projects:\n        return None\n\n    root = search_root or get_search_root()\n\n    # Build choice mapping: display string -&gt; actual path\n    choices: dict[str, Path] = {}\n    for project_path in projects:\n        display = _format_project_choice(project_path, root)\n        # Handle duplicate display names by appending parent info\n        if display in choices:\n            display = str(project_path.parent)\n        choices[display] = project_path\n\n    # Use autocomplete for fuzzy search if many projects, otherwise select\n    if len(choices) &gt; 5:\n        selected = questionary.autocomplete(\n            \"Select project (type to filter):\",\n            choices=list(choices.keys()),\n            match_middle=True,\n        ).ask()\n    else:\n        selected = questionary.select(\n            \"Select project:\",\n            choices=list(choices.keys()),\n        ).ask()\n\n    if selected is None:\n        return None\n\n    return choices.get(selected)\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.project.finder.discover_and_select_project","title":"<code>discover_and_select_project(root=None, max_depth=10)</code>","text":"<p>Combined discovery and selection flow.</p> <p>Finds dbt projects in the directory tree, prompts user to select one, and loads the selected project.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Path | None</code> <p>Search root (uses get_search_root() if None)</p> <code>None</code> <code>max_depth</code> <code>int</code> <p>Maximum directory depth to search</p> <code>10</code> <p>Returns:</p> Type Description <code>tuple[Path, DbtProject] | None</code> <p>Tuple of (project_path, loaded DbtProject) or None if cancelled/not found</p> Source code in <code>src/brix/modules/dbt/project/finder.py</code> <pre><code>def discover_and_select_project(\n    root: Path | None = None,\n    max_depth: int = 10,\n) -&gt; tuple[Path, DbtProject] | None:\n    \"\"\"Combined discovery and selection flow.\n\n    Finds dbt projects in the directory tree, prompts user to select one,\n    and loads the selected project.\n\n    Args:\n        root: Search root (uses get_search_root() if None)\n        max_depth: Maximum directory depth to search\n\n    Returns:\n        Tuple of (project_path, loaded DbtProject) or None if cancelled/not found\n    \"\"\"\n    import typer\n\n    search_root = root or get_search_root()\n    projects = find_dbt_projects(search_root, max_depth)\n\n    if not projects:\n        typer.echo(f\"No dbt projects found under {search_root}\", err=True)\n        return None\n\n    if len(projects) == 1:\n        # Only one project found, use it directly\n        project_path = projects[0]\n        typer.echo(f\"Found project: {project_path.parent}\")\n    else:\n        typer.echo(f\"Found {len(projects)} dbt projects\")\n        project_path = prompt_select_project(projects, search_root)\n        if project_path is None:\n            return None\n\n    # Load the project\n    try:\n        project = DbtProject.from_file(project_path)\n        return (project_path, project)\n    except Exception as e:\n        typer.echo(f\"Error loading project: {e}\", err=True)\n        return None\n</code></pre>"},{"location":"api/modules/#dbt-passthrough","title":"dbt Passthrough","text":""},{"location":"api/modules/#brix.modules.dbt.passthrough","title":"<code>brix.modules.dbt.passthrough</code>","text":"<p>dbt module - business logic for dbt operations.</p>"},{"location":"api/modules/#brix.modules.dbt.passthrough.DbtNotFoundError","title":"<code>DbtNotFoundError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when dbt executable cannot be found.</p> Source code in <code>src/brix/modules/dbt/passthrough.py</code> <pre><code>class DbtNotFoundError(Exception):\n    \"\"\"Raised when dbt executable cannot be found.\"\"\"\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.passthrough.ProjectPathCache","title":"<code>ProjectPathCache</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Cached project path for dbt passthrough.</p> Source code in <code>src/brix/modules/dbt/passthrough.py</code> <pre><code>class ProjectPathCache(BaseModel):\n    \"\"\"Cached project path for dbt passthrough.\"\"\"\n\n    project_path: Path\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.passthrough.CachedPathNotFoundError","title":"<code>CachedPathNotFoundError</code>","text":"<p>               Bases: <code>FileNotFoundError</code></p> <p>Raised when cached project path no longer exists.</p> Source code in <code>src/brix/modules/dbt/passthrough.py</code> <pre><code>class CachedPathNotFoundError(FileNotFoundError):\n    \"\"\"Raised when cached project path no longer exists.\"\"\"\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.passthrough.load_project_cache","title":"<code>load_project_cache()</code>","text":"<p>Load cached project path.</p> <p>Returns:</p> Type Description <code>Path | None</code> <p>Cached project path if valid, None otherwise.</p> <p>Raises:</p> Type Description <code>CachedPathNotFoundError</code> <p>If cached path no longer exists or is not a directory.</p> Source code in <code>src/brix/modules/dbt/passthrough.py</code> <pre><code>def load_project_cache() -&gt; Path | None:\n    \"\"\"Load cached project path.\n\n    Returns:\n        Cached project path if valid, None otherwise.\n\n    Raises:\n        CachedPathNotFoundError: If cached path no longer exists or is not a directory.\n    \"\"\"\n    logger = get_logger()\n    if not PROJECT_CACHE_FILE.exists():\n        logger.debug(\"Project cache file not found: %s\", PROJECT_CACHE_FILE)\n        return None\n    try:\n        cache = ProjectPathCache.model_validate_json(PROJECT_CACHE_FILE.read_text())\n    except (ValidationError, OSError) as e:\n        logger.debug(\"Failed to load project cache: %s\", e)\n        return None\n\n    # Check if cached path still exists (outside try/except to propagate error)\n    if not cache.project_path.exists():\n        logger.debug(\"Cached project path no longer exists: %s\", cache.project_path)\n        raise CachedPathNotFoundError(f\"Cached project path no longer exists: {cache.project_path}\")\n    if not cache.project_path.is_dir():\n        logger.debug(\"Cached project path is not a directory: %s\", cache.project_path)\n        raise CachedPathNotFoundError(f\"Cached project path is not a directory: {cache.project_path}\")\n\n    logger.debug(\"Loaded project cache: %s\", cache.project_path)\n    return cache.project_path\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.passthrough.save_project_cache","title":"<code>save_project_cache(project_path)</code>","text":"<p>Save project path to cache.</p> <p>Converts relative paths to absolute before saving.</p> <p>Parameters:</p> Name Type Description Default <code>project_path</code> <code>Path</code> <p>The project path to cache.</p> required Source code in <code>src/brix/modules/dbt/passthrough.py</code> <pre><code>def save_project_cache(project_path: Path) -&gt; None:\n    \"\"\"Save project path to cache.\n\n    Converts relative paths to absolute before saving.\n\n    Args:\n        project_path: The project path to cache.\n    \"\"\"\n    logger = get_logger()\n    absolute_path = project_path.resolve()\n    CACHE_DIR.mkdir(parents=True, exist_ok=True)\n    cache = ProjectPathCache(project_path=absolute_path)\n    PROJECT_CACHE_FILE.write_text(cache.model_dump_json())\n    logger.debug(\"Project cache saved: %s\", absolute_path)\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.passthrough.find_dbt_executable","title":"<code>find_dbt_executable()</code>","text":"<p>Find the dbt executable path.</p> <p>This function handles two scenarios: 1. brix is installed in the same venv as dbt - dbt should be directly available 2. brix is installed as a global tool - need to discover project venv with dbt</p> <p>Returns:</p> Type Description <code>str</code> <p>Path to the dbt executable.</p> <p>Raises:</p> Type Description <code>DbtNotFoundError</code> <p>If dbt cannot be found.</p> Source code in <code>src/brix/modules/dbt/passthrough.py</code> <pre><code>def find_dbt_executable() -&gt; str:\n    \"\"\"Find the dbt executable path.\n\n    This function handles two scenarios:\n    1. brix is installed in the same venv as dbt - dbt should be directly available\n    2. brix is installed as a global tool - need to discover project venv with dbt\n\n    Returns:\n        Path to the dbt executable.\n\n    Raises:\n        DbtNotFoundError: If dbt cannot be found.\n    \"\"\"\n    # TODO: Implement venv discovery logic for when brix is installed globally\n    # but dbt is in a project-specific venv. This could involve:\n    # - Looking for .venv/ in current directory or parent directories\n    # - Checking for pyproject.toml/requirements.txt to identify project root\n    # - Activating the discovered venv or returning path to its dbt executable\n\n    # For now, assume dbt is available in PATH (same venv scenario)\n    return \"dbt\"\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.passthrough.pre_dbt_hook","title":"<code>pre_dbt_hook()</code>","text":"<p>Hook for setup before running dbt. Placeholder for future logic.</p> Source code in <code>src/brix/modules/dbt/passthrough.py</code> <pre><code>def pre_dbt_hook() -&gt; None:\n    \"\"\"Hook for setup before running dbt. Placeholder for future logic.\"\"\"\n    # TODO: Placeholder for other stuff that has to happen before running dbt.\n    pass\n</code></pre>"},{"location":"api/modules/#brix.modules.dbt.passthrough.run_dbt","title":"<code>run_dbt(args, project_path=None)</code>","text":"<p>Run dbt with the given arguments and return exit code.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str]</code> <p>List of arguments to pass to dbt.</p> required <code>project_path</code> <code>Path | None</code> <p>Optional directory to run dbt in.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Exit code from the dbt process (1 if dbt not found or invalid project path).</p> Source code in <code>src/brix/modules/dbt/passthrough.py</code> <pre><code>def run_dbt(args: list[str], project_path: Path | None = None) -&gt; int:\n    \"\"\"Run dbt with the given arguments and return exit code.\n\n    Args:\n        args: List of arguments to pass to dbt.\n        project_path: Optional directory to run dbt in.\n\n    Returns:\n        Exit code from the dbt process (1 if dbt not found or invalid project path).\n    \"\"\"\n    logger = get_logger()\n\n    pre_dbt_hook()\n\n    # Validate project path if provided\n    if project_path is not None:\n        if not project_path.exists():\n            logger.error(\"Project path does not exist: %s\", project_path)\n            return 1\n        if not project_path.is_dir():\n            logger.error(\"Project path is not a directory: %s\", project_path)\n            return 1\n\n    try:\n        dbt_path = find_dbt_executable()\n    except DbtNotFoundError as e:\n        logger.error(str(e))\n        return 1\n\n    cwd = project_path.resolve() if project_path else None\n    logger.debug(\"Executing dbt command: %s %s (cwd=%s)\", dbt_path, \" \".join(args), cwd)\n    try:\n        # \"unsafe\" passthrough is intended, we trust the user to pass valid arguments. Its their local machine.\n        result = subprocess.run([dbt_path, *args], cwd=cwd)  # noqa: S603\n    except FileNotFoundError:\n        logger.error(\n            \"dbt not found in PATH. Ensure dbt is installed and available.\\n\"\n            \"If using a virtual environment, make sure it's activated or install brix in the same environment as dbt.\"\n        )\n        return 1\n    except OSError as e:\n        logger.error(\"Failed to execute dbt: %s\", e)\n        return 1\n\n    logger.debug(\"dbt exited with code: %d\", result.returncode)\n\n    return result.returncode\n</code></pre>"},{"location":"api/modules/#logging","title":"Logging","text":""},{"location":"api/modules/#brix.utils.logging","title":"<code>brix.utils.logging</code>","text":"<p>Terraform-style logging system for brix CLI.</p> Environment variables <p>BRIX_LOG: Log level (TRACE, DEBUG, INFO, WARN, ERROR, OFF) BRIX_LOG_PATH: File path for log output BRIX_LOG_JSON: Enable JSON format (true/false)</p> <p>Logging convention: Use %-formatting for logger calls (lazy evaluation), f-strings elsewhere. This is Python logging best practice.</p>"},{"location":"api/modules/#brix.utils.logging.LogLevel","title":"<code>LogLevel</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Log levels matching Terraform's TF_LOG.</p> <p>Custom TRACE level added below DEBUG (Python's DEBUG=10).</p> Source code in <code>src/brix/utils/logging.py</code> <pre><code>class LogLevel(IntEnum):\n    \"\"\"Log levels matching Terraform's TF_LOG.\n\n    Custom TRACE level added below DEBUG (Python's DEBUG=10).\n    \"\"\"\n\n    TRACE = 5\n    DEBUG = 10\n    INFO = 20\n    WARN = 30\n    ERROR = 40\n    OFF = 100\n</code></pre>"},{"location":"api/modules/#brix.utils.logging.LogConfig","title":"<code>LogConfig</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Logging configuration from environment variables.</p> Environment variables <p>BRIX_LOG: Log level (TRACE, DEBUG, INFO, WARN, ERROR, OFF) BRIX_LOG_PATH: File path for log output BRIX_LOG_JSON: Enable JSON format (true/false)</p> Source code in <code>src/brix/utils/logging.py</code> <pre><code>class LogConfig(BaseSettings):\n    \"\"\"Logging configuration from environment variables.\n\n    Environment variables:\n        BRIX_LOG: Log level (TRACE, DEBUG, INFO, WARN, ERROR, OFF)\n        BRIX_LOG_PATH: File path for log output\n        BRIX_LOG_JSON: Enable JSON format (true/false)\n    \"\"\"\n\n    model_config = SettingsConfigDict(\n        env_prefix=\"BRIX_\",\n        case_sensitive=False,\n    )\n\n    log: Literal[\"TRACE\", \"DEBUG\", \"INFO\", \"WARN\", \"ERROR\", \"OFF\"] = \"ERROR\"\n    log_path: Path | None = None\n    log_json: bool = False\n\n    @field_validator(\"log\", mode=\"before\")\n    @classmethod\n    def normalize_log_level(cls, v: str) -&gt; str:\n        \"\"\"Normalize log level to uppercase.\"\"\"\n        if isinstance(v, str):\n            v = v.upper()\n            # Handle WARNING -&gt; WARN alias\n            if v == \"WARNING\":\n                return \"WARN\"\n        return v\n</code></pre>"},{"location":"api/modules/#brix.utils.logging.LogConfig.normalize_log_level","title":"<code>normalize_log_level(v)</code>  <code>classmethod</code>","text":"<p>Normalize log level to uppercase.</p> Source code in <code>src/brix/utils/logging.py</code> <pre><code>@field_validator(\"log\", mode=\"before\")\n@classmethod\ndef normalize_log_level(cls, v: str) -&gt; str:\n    \"\"\"Normalize log level to uppercase.\"\"\"\n    if isinstance(v, str):\n        v = v.upper()\n        # Handle WARNING -&gt; WARN alias\n        if v == \"WARNING\":\n            return \"WARN\"\n    return v\n</code></pre>"},{"location":"api/modules/#brix.utils.logging.BrixFormatter","title":"<code>BrixFormatter</code>","text":"<p>               Bases: <code>Formatter</code></p> <p>Human-readable log formatter for console output.</p> <p>Format: <code>[2024-01-15T10:30:45Z] [DEBUG] message</code></p> Source code in <code>src/brix/utils/logging.py</code> <pre><code>class BrixFormatter(logging.Formatter):\n    \"\"\"Human-readable log formatter for console output.\n\n    Format: ``[2024-01-15T10:30:45Z] [DEBUG] message``\n    \"\"\"\n\n    def format(self, record: logging.LogRecord) -&gt; str:\n        \"\"\"Format the log record as human-readable text.\"\"\"\n        timestamp = datetime.fromtimestamp(record.created, tz=timezone.utc).isoformat()\n        level = record.levelname\n        return f\"[{timestamp}] [{level}] {record.getMessage()}\"\n</code></pre>"},{"location":"api/modules/#brix.utils.logging.BrixFormatter.format","title":"<code>format(record)</code>","text":"<p>Format the log record as human-readable text.</p> Source code in <code>src/brix/utils/logging.py</code> <pre><code>def format(self, record: logging.LogRecord) -&gt; str:\n    \"\"\"Format the log record as human-readable text.\"\"\"\n    timestamp = datetime.fromtimestamp(record.created, tz=timezone.utc).isoformat()\n    level = record.levelname\n    return f\"[{timestamp}] [{level}] {record.getMessage()}\"\n</code></pre>"},{"location":"api/modules/#brix.utils.logging.BrixJsonFormatter","title":"<code>BrixJsonFormatter</code>","text":"<p>               Bases: <code>Formatter</code></p> <p>JSON log formatter for file output and machine parsing.</p> <p>Output: {\"@timestamp\": \"...\", \"@level\": \"DEBUG\", \"@message\": \"...\", \"@module\": \"...\"}</p> Source code in <code>src/brix/utils/logging.py</code> <pre><code>class BrixJsonFormatter(logging.Formatter):\n    \"\"\"JSON log formatter for file output and machine parsing.\n\n    Output: {\"@timestamp\": \"...\", \"@level\": \"DEBUG\", \"@message\": \"...\", \"@module\": \"...\"}\n    \"\"\"\n\n    def format(self, record: logging.LogRecord) -&gt; str:\n        \"\"\"Format the log record as JSON.\"\"\"\n        log_obj: dict[str, Any] = {\n            \"@timestamp\": datetime.fromtimestamp(record.created, tz=timezone.utc).isoformat(),\n            \"@level\": record.levelname,\n            \"@message\": record.getMessage(),\n            \"@module\": record.module,\n        }\n        if record.exc_info:\n            log_obj[\"@exception\"] = self.formatException(record.exc_info)\n        return json.dumps(log_obj)\n</code></pre>"},{"location":"api/modules/#brix.utils.logging.BrixJsonFormatter.format","title":"<code>format(record)</code>","text":"<p>Format the log record as JSON.</p> Source code in <code>src/brix/utils/logging.py</code> <pre><code>def format(self, record: logging.LogRecord) -&gt; str:\n    \"\"\"Format the log record as JSON.\"\"\"\n    log_obj: dict[str, Any] = {\n        \"@timestamp\": datetime.fromtimestamp(record.created, tz=timezone.utc).isoformat(),\n        \"@level\": record.levelname,\n        \"@message\": record.getMessage(),\n        \"@module\": record.module,\n    }\n    if record.exc_info:\n        log_obj[\"@exception\"] = self.formatException(record.exc_info)\n    return json.dumps(log_obj)\n</code></pre>"},{"location":"api/modules/#brix.utils.logging.setup_logging","title":"<code>setup_logging(level=None, log_path=None, json_format=None)</code>","text":"<p>Initialize the brix logger with config from env and CLI overrides.</p> <p>CLI arguments override environment variables. Thread-safe initialization with singleton pattern.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>str | None</code> <p>CLI override for BRIX_LOG</p> <code>None</code> <code>log_path</code> <code>Path | None</code> <p>CLI override for BRIX_LOG_PATH</p> <code>None</code> <code>json_format</code> <code>bool | None</code> <p>CLI override for BRIX_LOG_JSON</p> <code>None</code> <p>Returns:</p> Type Description <code>Logger</code> <p>Configured logger instance</p> Source code in <code>src/brix/utils/logging.py</code> <pre><code>def setup_logging(\n    level: str | None = None,\n    log_path: Path | None = None,\n    json_format: bool | None = None,\n) -&gt; logging.Logger:\n    \"\"\"Initialize the brix logger with config from env and CLI overrides.\n\n    CLI arguments override environment variables.\n    Thread-safe initialization with singleton pattern.\n\n    Args:\n        level: CLI override for BRIX_LOG\n        log_path: CLI override for BRIX_LOG_PATH\n        json_format: CLI override for BRIX_LOG_JSON\n\n    Returns:\n        Configured logger instance\n    \"\"\"\n    global _logger\n\n    with _lock:\n        if _logger is not None:\n            return _logger\n\n        # Load config from env vars\n        config = LogConfig()\n\n        # Apply CLI overrides\n        effective_level = level.upper() if level else config.log\n        effective_path = log_path if log_path is not None else config.log_path\n        effective_json = json_format if json_format is not None else config.log_json\n\n        # Create logger\n        _logger = logging.getLogger(\"brix\")\n        _logger.setLevel(LogLevel[effective_level].value)\n        _logger.handlers.clear()  # Prevent duplicate handlers\n\n        if effective_level == \"OFF\":\n            _logger.addHandler(logging.NullHandler())\n            return _logger\n\n        # Console handler (stderr, human-readable by default)\n        console_handler = logging.StreamHandler()\n        if effective_json and not effective_path:\n            # JSON to console only if no file path and JSON requested\n            console_handler.setFormatter(BrixJsonFormatter())\n        else:\n            console_handler.setFormatter(BrixFormatter())\n        _logger.addHandler(console_handler)\n\n        # File handler (JSON by default for machine parsing, unless explicitly disabled)\n        if effective_path:\n            file_handler = logging.FileHandler(effective_path)\n            # Use JSON for files unless json_format was explicitly set to False\n            use_json_for_file = json_format is not False\n            if use_json_for_file:\n                file_handler.setFormatter(BrixJsonFormatter())\n            else:\n                file_handler.setFormatter(BrixFormatter())\n            _logger.addHandler(file_handler)\n\n        return _logger\n</code></pre>"},{"location":"api/modules/#brix.utils.logging.get_logger","title":"<code>get_logger()</code>","text":"<p>Get the brix logger (initializes with defaults if needed).</p> <p>For use throughout the codebase.</p> Source code in <code>src/brix/utils/logging.py</code> <pre><code>def get_logger() -&gt; logging.Logger:\n    \"\"\"Get the brix logger (initializes with defaults if needed).\n\n    For use throughout the codebase.\n    \"\"\"\n    global _logger\n    if _logger is None:\n        return setup_logging()\n    return _logger\n</code></pre>"},{"location":"api/modules/#brix.utils.logging.reset_logger","title":"<code>reset_logger()</code>","text":"<p>Reset the logger singleton (for testing).</p> Source code in <code>src/brix/utils/logging.py</code> <pre><code>def reset_logger() -&gt; None:\n    \"\"\"Reset the logger singleton (for testing).\"\"\"\n    global _logger\n    with _lock:\n        if _logger is not None:\n            _logger.handlers.clear()\n            _logger = None\n</code></pre>"},{"location":"developer-guide/adding-adapters/","title":"Adding Adapters","text":"<p>Guide for adding new database adapter support to brix.</p>"},{"location":"developer-guide/adding-adapters/#overview","title":"Overview","text":"<p>Brix supports multiple dbt adapters through Pydantic models with discriminated unions. Adding a new adapter requires:</p> <ol> <li>Creating a Pydantic model for the adapter</li> <li>Adding to the discriminated union</li> <li>Implementing interactive prompts</li> <li>Adding tests</li> </ol>"},{"location":"developer-guide/adding-adapters/#step-1-create-the-model","title":"Step 1: Create the Model","text":"<p>Add a new model in <code>src/brix/modules/dbt/profile/models.py</code>:</p> <pre><code>from pydantic import BaseModel, Field\n\nclass SnowflakeOutput(BaseModel):\n    \"\"\"Snowflake adapter output configuration.\"\"\"\n\n    type: Literal[\"snowflake\"] = \"snowflake\"\n    account: str = Field(..., description=\"Snowflake account identifier\")\n    user: str = Field(..., description=\"Username\")\n    password: str | None = Field(None, description=\"Password (use env_var)\")\n    role: str = Field(..., description=\"Role to use\")\n    database: str = Field(..., description=\"Database name\")\n    warehouse: str = Field(..., description=\"Warehouse name\")\n    schema_: str = Field(..., alias=\"schema\", description=\"Schema name\")\n    threads: int = Field(4, description=\"Number of threads\")\n\n    model_config = ConfigDict(populate_by_name=True)\n</code></pre> <p>Key considerations: - Use <code>Literal[\"adapter_name\"]</code> for the <code>type</code> field - Use <code>Field(...)</code> for required fields - Use <code>Field(alias=\"schema\")</code> for reserved Python keywords - Document fields with <code>description</code></p>"},{"location":"developer-guide/adding-adapters/#step-2-add-to-discriminated-union","title":"Step 2: Add to Discriminated Union","text":"<p>Update the <code>OutputConfig</code> type in <code>models.py</code>:</p> <pre><code>OutputConfig = Annotated[\n    DuckDbOutput | DatabricksOutput | SnowflakeOutput,\n    Field(discriminator=\"type\"),\n]\n</code></pre> <p>The discriminator ensures the correct model is used based on the <code>type</code> field.</p>"},{"location":"developer-guide/adding-adapters/#step-3-add-interactive-prompts","title":"Step 3: Add Interactive Prompts","text":"<p>Add prompts in <code>src/brix/modules/dbt/profile/prompts.py</code>:</p> <pre><code>import questionary\n\ndef prompt_snowflake_output(name: str = \"\") -&gt; SnowflakeOutput:\n    \"\"\"Prompt for Snowflake output configuration.\"\"\"\n    name = name or questionary.text(\n        \"Output name:\",\n        default=\"prod\",\n    ).ask()\n\n    account = questionary.text(\n        \"Snowflake account:\",\n        instruction=\"e.g., xy12345.us-east-1\",\n    ).ask()\n\n    user = questionary.text(\"Username:\").ask()\n\n    password = questionary.password(\n        \"Password (leave empty to use env var):\"\n    ).ask()\n\n    role = questionary.text(\n        \"Role:\",\n        default=\"ACCOUNTADMIN\",\n    ).ask()\n\n    database = questionary.text(\"Database:\").ask()\n    warehouse = questionary.text(\"Warehouse:\").ask()\n    schema = questionary.text(\"Schema:\", default=\"public\").ask()\n\n    threads = int(questionary.text(\n        \"Threads:\",\n        default=\"4\",\n    ).ask())\n\n    # Use env_var for password if not provided\n    password_value = (\n        password if password\n        else \"{{ env_var('DBT_SNOWFLAKE_PASSWORD') }}\"\n    )\n\n    return SnowflakeOutput(\n        type=\"snowflake\",\n        account=account,\n        user=user,\n        password=password_value,\n        role=role,\n        database=database,\n        warehouse=warehouse,\n        schema=schema,\n        threads=threads,\n    )\n</code></pre>"},{"location":"developer-guide/adding-adapters/#step-4-register-in-adapter-selection","title":"Step 4: Register in Adapter Selection","text":"<p>Update the adapter selection in <code>prompts.py</code>:</p> <pre><code>def prompt_output_type() -&gt; str:\n    \"\"\"Prompt for adapter type selection.\"\"\"\n    return questionary.select(\n        \"Select adapter type:\",\n        choices=[\n            \"duckdb\",\n            \"databricks\",\n            \"snowflake\",  # Add new adapter\n        ],\n    ).ask()\n\n\ndef prompt_new_output(adapter_type: str, name: str = \"\") -&gt; OutputConfig:\n    \"\"\"Create output based on selected adapter type.\"\"\"\n    if adapter_type == \"duckdb\":\n        return prompt_duckdb_output(name)\n    elif adapter_type == \"databricks\":\n        return prompt_databricks_output(name)\n    elif adapter_type == \"snowflake\":\n        return prompt_snowflake_output(name)\n    else:\n        raise ValueError(f\"Unknown adapter type: {adapter_type}\")\n</code></pre>"},{"location":"developer-guide/adding-adapters/#step-5-add-tests","title":"Step 5: Add Tests","text":""},{"location":"developer-guide/adding-adapters/#unit-tests","title":"Unit Tests","text":"<p>Create <code>tests/unit/test_snowflake_models.py</code>:</p> <pre><code>import pytest\nfrom brix.modules.dbt.profile.models import SnowflakeOutput, OutputConfig\n\ndef test_snowflake_output_creation():\n    output = SnowflakeOutput(\n        account=\"xy12345.us-east-1\",\n        user=\"dbt_user\",\n        password=\"{{ env_var('DBT_SNOWFLAKE_PASSWORD') }}\",\n        role=\"TRANSFORM_ROLE\",\n        database=\"ANALYTICS\",\n        warehouse=\"COMPUTE_WH\",\n        schema=\"dbt_prod\",\n    )\n    assert output.type == \"snowflake\"\n    assert output.account == \"xy12345.us-east-1\"\n\ndef test_snowflake_output_discriminator():\n    \"\"\"Test that discriminated union correctly identifies Snowflake.\"\"\"\n    data = {\n        \"type\": \"snowflake\",\n        \"account\": \"xy12345\",\n        \"user\": \"user\",\n        \"role\": \"role\",\n        \"database\": \"db\",\n        \"warehouse\": \"wh\",\n        \"schema\": \"public\",\n    }\n    # This would be used when parsing YAML\n    from pydantic import TypeAdapter\n    adapter = TypeAdapter(OutputConfig)\n    output = adapter.validate_python(data)\n    assert isinstance(output, SnowflakeOutput)\n</code></pre>"},{"location":"developer-guide/adding-adapters/#integration-tests","title":"Integration Tests","text":"<p>Create <code>tests/integration/test_snowflake_profile.py</code>:</p> <pre><code>import pytest\nfrom pathlib import Path\nfrom brix.modules.dbt.profile.models import DbtProfiles, SnowflakeOutput\n\n@pytest.mark.integration\ndef test_snowflake_profile_yaml_roundtrip(tmp_path: Path):\n    \"\"\"Test Snowflake profile YAML serialization.\"\"\"\n    profiles = DbtProfiles(\n        profiles={\n            \"snowflake_project\": {\n                \"target\": \"prod\",\n                \"outputs\": {\n                    \"prod\": SnowflakeOutput(\n                        account=\"xy12345\",\n                        user=\"dbt\",\n                        role=\"transform\",\n                        database=\"analytics\",\n                        warehouse=\"compute\",\n                        schema=\"dbt\",\n                    ),\n                },\n            },\n        },\n    )\n\n    yaml_path = tmp_path / \"profiles.yml\"\n    yaml_path.write_text(profiles.to_yaml())\n\n    loaded = DbtProfiles.from_yaml(yaml_path.read_text())\n    assert \"snowflake_project\" in loaded.profiles\n</code></pre>"},{"location":"developer-guide/adding-adapters/#step-6-update-documentation","title":"Step 6: Update Documentation","text":"<p>Add adapter documentation in <code>docs/user-guide/profiles.md</code>:</p> <p><pre><code>### Snowflake\n\nFor Snowflake data warehouse.\n\n#### Configuration\n\n```yaml\noutputs:\n  prod:\n    type: snowflake\n    account: xy12345.us-east-1\n    user: dbt_user\n    password: \"{{ env_var('DBT_SNOWFLAKE_PASSWORD') }}\"\n    role: TRANSFORM_ROLE\n    database: ANALYTICS\n    warehouse: COMPUTE_WH\n    schema: dbt_prod\n    threads: 4\n</code></pre> ```</p>"},{"location":"developer-guide/adding-adapters/#checklist","title":"Checklist","text":"<ul> <li>[ ] Create Pydantic model with all required fields</li> <li>[ ] Add to <code>OutputConfig</code> discriminated union</li> <li>[ ] Implement <code>prompt_*_output()</code> function</li> <li>[ ] Update <code>prompt_output_type()</code> choices</li> <li>[ ] Update <code>prompt_new_output()</code> dispatcher</li> <li>[ ] Add unit tests for model validation</li> <li>[ ] Add integration tests for YAML roundtrip</li> <li>[ ] Update documentation with configuration examples</li> <li>[ ] Run full test suite: <code>uv run poe test</code></li> <li>[ ] Run pre-commit: <code>uv run poe pre-commit</code></li> </ul>"},{"location":"developer-guide/architecture/","title":"Architecture","text":"<p>Brix follows a layered architecture that separates CLI concerns from business logic.</p>"},{"location":"developer-guide/architecture/#project-structure","title":"Project Structure","text":"<pre><code>src/brix/\n\u251c\u2500\u2500 commands/              # CLI layer (Typer)\n\u2502   \u2514\u2500\u2500 dbt/\n\u2502       \u251c\u2500\u2500 __init__.py    # DbtGroup passthrough\n\u2502       \u251c\u2500\u2500 profile.py     # Profile CLI commands\n\u2502       \u2514\u2500\u2500 project.py     # Project CLI commands\n\u251c\u2500\u2500 modules/               # Business logic layer\n\u2502   \u2514\u2500\u2500 dbt/\n\u2502       \u251c\u2500\u2500 passthrough.py # dbt CLI execution\n\u2502       \u251c\u2500\u2500 profile/\n\u2502       \u2502   \u251c\u2500\u2500 models.py  # Pydantic models\n\u2502       \u2502   \u251c\u2500\u2500 service.py # Core operations\n\u2502       \u2502   \u251c\u2500\u2500 editor.py  # CRUD operations\n\u2502       \u2502   \u2514\u2500\u2500 prompts.py # Interactive prompts\n\u2502       \u2514\u2500\u2500 project/\n\u2502           \u251c\u2500\u2500 models.py\n\u2502           \u251c\u2500\u2500 service.py\n\u2502           \u251c\u2500\u2500 editor.py\n\u2502           \u251c\u2500\u2500 prompts.py\n\u2502           \u2514\u2500\u2500 finder.py  # Project discovery\n\u251c\u2500\u2500 templates/             # Bundled templates\n\u251c\u2500\u2500 utils/\n\u2502   \u2514\u2500\u2500 logging.py         # Terraform-style logger\n\u251c\u2500\u2500 version_check.py       # Background version checking\n\u2514\u2500\u2500 main.py                # Entry point\n</code></pre>"},{"location":"developer-guide/architecture/#layer-separation","title":"Layer Separation","text":""},{"location":"developer-guide/architecture/#cli-layer-commands","title":"CLI Layer (<code>commands/</code>)","text":"<p>Responsibilities: - Argument parsing with Typer - Output formatting (typer.echo) - Error handling and exit codes - No business logic</p>"},{"location":"developer-guide/architecture/#business-logic-layer-modules","title":"Business Logic Layer (<code>modules/</code>)","text":"<p>Responsibilities: - Core operations (init, edit, validate) - Data models (Pydantic) - File I/O - No CLI dependencies</p> <p>This separation allows: - Unit testing without CLI - Reuse as a library - Clear responsibility boundaries</p>"},{"location":"developer-guide/architecture/#key-patterns","title":"Key Patterns","text":""},{"location":"developer-guide/architecture/#dbtgroup-passthrough","title":"DbtGroup Passthrough","text":"<p>The <code>DbtGroup</code> class in <code>commands/dbt/__init__.py</code> intercepts unknown commands and passes them to the native dbt CLI.</p> <pre><code>class DbtGroup(TyperGroup):\n    def resolve_command(self, ctx, args):\n        try:\n            return super().resolve_command(ctx, args)\n        except click.UsageError:\n            return None, None, args  # Pass through to dbt\n\n    def invoke(self, ctx):\n        if no_command_matched:\n            run_dbt(args)  # Execute native dbt\n</code></pre> <p>This enables <code>brix dbt run</code>, <code>brix dbt test</code>, etc. to work transparently.</p>"},{"location":"developer-guide/architecture/#pydantic-models-with-discriminated-unions","title":"Pydantic Models with Discriminated Unions","text":"<p>Profile models use discriminated unions for adapter types:</p> <pre><code>OutputConfig = Annotated[\n    DuckDbOutput | DatabricksOutput,\n    Field(discriminator=\"type\")\n]\n</code></pre> <p>This provides: - Type-safe YAML parsing - Automatic validation - Clear error messages</p>"},{"location":"developer-guide/architecture/#configuration-with-pydantic-settings","title":"Configuration with pydantic-settings","text":"<p>All configuration uses <code>BaseSettings</code> with <code>BRIX_</code> prefix:</p> <pre><code>class ProfileConfig(BaseSettings):\n    profile_path: Path = Path(\"~/.dbt/profiles.yml\")\n\n    model_config = SettingsConfigDict(env_prefix=\"BRIX_DBT_\")\n</code></pre> <p>Override chain: CLI args &gt; env vars &gt; defaults</p>"},{"location":"developer-guide/architecture/#result-objects","title":"Result Objects","text":"<p>Operations return structured result objects instead of exceptions:</p> <pre><code>@dataclass\nclass ProfileInitResult:\n    success: bool\n    path: Path\n    action: str  # \"created\", \"exists\", \"overwritten\"\n    message: str\n</code></pre>"},{"location":"developer-guide/architecture/#thread-safe-logging","title":"Thread-safe Logging","text":"<p>The logger is a singleton with thread-safe initialization:</p> <pre><code>logger = get_logger()  # Always returns same instance\nlogger.debug(\"message %s\", arg)  # Lazy evaluation\n</code></pre> <p>Features: - Custom TRACE level - Terraform-style output - JSON format support - Non-blocking version check</p>"},{"location":"developer-guide/architecture/#template-system","title":"Template System","text":"<p>Templates are bundled with the package and loaded via <code>importlib.resources</code>:</p> <pre><code>from brix.templates import get_template\n\ncontent = get_template(\"profiles.yml\")\n</code></pre>"},{"location":"developer-guide/architecture/#data-flow","title":"Data Flow","text":"<pre><code>User Input (CLI)\n      \u2193\ncommands/ (Typer)\n      \u2502\n      \u251c\u2500\u2500 Parse arguments\n      \u251c\u2500\u2500 Validate input\n      \u2514\u2500\u2500 Call business logic\n      \u2193\nmodules/\n      \u2502\n      \u251c\u2500\u2500 models.py \u2192 Validate data structures\n      \u251c\u2500\u2500 service.py \u2192 Execute operations\n      \u251c\u2500\u2500 editor.py \u2192 Modify files\n      \u2514\u2500\u2500 prompts.py \u2192 Interactive input\n      \u2193\nFile System / dbt CLI\n      \u2193\nResult object\n      \u2193\ncommands/\n      \u2502\n      \u2514\u2500\u2500 Format output (typer.echo)\n      \u2193\nUser Output\n</code></pre>"},{"location":"developer-guide/architecture/#module-structure-convention","title":"Module Structure Convention","text":"<p>Each domain follows this structure:</p> File Purpose <code>models.py</code> Pydantic data models <code>service.py</code> Initialization, resolution, fetching <code>editor.py</code> CRUD operations <code>prompts.py</code> questionary interactive prompts"},{"location":"developer-guide/architecture/#dependencies","title":"Dependencies","text":"<p>Runtime: - <code>typer</code> - CLI framework - <code>pydantic</code> / <code>pydantic-settings</code> - Data validation - <code>questionary</code> - Interactive prompts - <code>httpx</code> - HTTP requests</p> <p>Development: - <code>ruff</code> - Linting and formatting - <code>ty</code> - Type checking - <code>pytest</code> - Testing - <code>dbt-core</code>, <code>dbt-databricks</code>, <code>dbt-duckdb</code> - Integration tests</p>"},{"location":"developer-guide/contributing/","title":"Contributing","text":"<p>Guide for contributing to brix development.</p>"},{"location":"developer-guide/contributing/#development-setup","title":"Development Setup","text":""},{"location":"developer-guide/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li>uv package manager</li> <li>Git</li> </ul>"},{"location":"developer-guide/contributing/#clone-and-install","title":"Clone and Install","text":"<pre><code>git clone https://github.com/Spycner/brix.git\ncd brix\nuv sync\n</code></pre>"},{"location":"developer-guide/contributing/#verify-setup","title":"Verify Setup","text":"<pre><code>uv run brix --version\nuv run poe test\n</code></pre>"},{"location":"developer-guide/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"developer-guide/contributing/#task-runner","title":"Task Runner","text":"<p>Use poethepoet for common tasks:</p> <pre><code>uv run poe lint            # Run ruff linting\nuv run poe format          # Run ruff formatting\nuv run poe typecheck       # Run ty type checking\nuv run poe test            # Run all tests\nuv run poe test-unit       # Run unit tests only\nuv run poe test-integration # Run integration tests\nuv run poe test-e2e        # Run e2e tests\nuv run poe check           # Run lint + typecheck\nuv run poe pre-commit      # Run pre-commit hooks\n</code></pre>"},{"location":"developer-guide/contributing/#running-the-cli","title":"Running the CLI","text":"<pre><code>uv run brix --help\nuv run brix dbt profile init\n</code></pre>"},{"location":"developer-guide/contributing/#running-tests","title":"Running Tests","text":"<pre><code># All tests\nuv run poe test\n\n# Specific test file\nuv run pytest tests/unit/test_profile_models.py -v\n\n# Specific test\nuv run pytest tests/unit/test_profile_models.py::test_duckdb_output -v\n\n# With coverage\nuv run pytest --cov=brix\n</code></pre>"},{"location":"developer-guide/contributing/#code-style","title":"Code Style","text":""},{"location":"developer-guide/contributing/#linting-and-formatting","title":"Linting and Formatting","text":"<p>Brix uses ruff for linting and formatting:</p> <pre><code># Check for issues\nuv run poe lint\n\n# Auto-format\nuv run poe format\n</code></pre>"},{"location":"developer-guide/contributing/#type-hints","title":"Type Hints","text":"<p>All public functions require type hints (ANN rules enforced):</p> <pre><code>def init_profile(\n    profile_path: Path,\n    force: bool = False,\n    template_name: str = \"profiles.yml\",\n) -&gt; ProfileInitResult:\n    ...\n</code></pre>"},{"location":"developer-guide/contributing/#docstrings","title":"Docstrings","text":"<p>Use Google-style docstrings:</p> <pre><code>def init_profile(profile_path: Path, force: bool = False) -&gt; ProfileInitResult:\n    \"\"\"Initialize a dbt profile from template.\n\n    Creates a profiles.yml file at the specified path with a DuckDB\n    configuration for local development.\n\n    Args:\n        profile_path: Path where profiles.yml will be created.\n        force: If True, overwrite existing file.\n\n    Returns:\n        ProfileInitResult with success status and message.\n\n    Raises:\n        ProfileExistsError: If file exists and force is False.\n    \"\"\"\n</code></pre>"},{"location":"developer-guide/contributing/#line-length","title":"Line Length","text":"<p>Maximum 120 characters per line.</p>"},{"location":"developer-guide/contributing/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>Always run pre-commit before committing:</p> <pre><code>uv run poe pre-commit\n</code></pre> <p>Or install hooks to run automatically:</p> <pre><code>uv run pre-commit install\n</code></pre>"},{"location":"developer-guide/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the repository</li> <li>Create a branch from <code>main</code></li> <li>Make changes following code style guidelines</li> <li>Add tests for new functionality</li> <li>Run checks: <code>uv run poe check &amp;&amp; uv run poe test</code></li> <li>Run pre-commit: <code>uv run poe pre-commit</code></li> <li>Create PR with clear description</li> </ol>"},{"location":"developer-guide/contributing/#commit-messages","title":"Commit Messages","text":"<p>Follow conventional commits:</p> <pre><code>feat: add snowflake adapter support\nfix: handle empty profiles.yml gracefully\ndocs: update installation instructions\ntest: add integration tests for project init\nrefactor: extract validation logic to separate module\n</code></pre>"},{"location":"developer-guide/contributing/#pr-description","title":"PR Description","text":"<p>Include: - Summary of changes - Related issues - Test coverage - Breaking changes (if any)</p>"},{"location":"developer-guide/contributing/#adding-features","title":"Adding Features","text":""},{"location":"developer-guide/contributing/#adding-a-new-command","title":"Adding a New Command","text":"<ol> <li>Create command file in <code>commands/dbt/</code>:</li> </ol> <pre><code># commands/dbt/new_command.py\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef action(name: str) -&gt; None:\n    \"\"\"Command description.\"\"\"\n    from brix.modules.dbt.new_feature import do_action\n    result = do_action(name)\n    typer.echo(result.message)\n</code></pre> <ol> <li>Register in <code>commands/dbt/__init__.py</code>:</li> </ol> <pre><code>from brix.commands.dbt.new_command import app as new_command_app\n\napp.add_typer(new_command_app, name=\"new-command\")\n</code></pre> <ol> <li>Add business logic in <code>modules/dbt/new_feature/</code></li> </ol>"},{"location":"developer-guide/contributing/#adding-tests","title":"Adding Tests","text":"<p>Place tests in the appropriate directory:</p> <ul> <li><code>tests/unit/</code> - No external dependencies, mocked I/O</li> <li><code>tests/integration/</code> - May require dbt, real file operations</li> <li><code>tests/e2e/</code> - Full dbt execution, real commands</li> </ul> <p>Use markers for non-unit tests:</p> <pre><code>import pytest\n\n@pytest.mark.integration\ndef test_profile_creation():\n    ...\n\n@pytest.mark.e2e\ndef test_full_workflow():\n    ...\n</code></pre>"},{"location":"developer-guide/contributing/#release-process","title":"Release Process","text":"<p>Releases are automated via semantic-release:</p> <ol> <li>Merge PR to <code>main</code></li> <li>GitHub Action analyzes commits</li> <li>Bumps version based on commit types</li> <li>Creates GitHub release</li> <li>Publishes to PyPI</li> </ol> <p>Version bumps: - <code>fix:</code> \u2192 patch (1.0.x) - <code>feat:</code> \u2192 minor (1.x.0) - <code>BREAKING CHANGE:</code> \u2192 major (x.0.0)</p>"},{"location":"developer-guide/testing/","title":"Testing","text":"<p>Guide for testing brix functionality.</p>"},{"location":"developer-guide/testing/#test-structure","title":"Test Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 unit/           # No external dependencies\n\u251c\u2500\u2500 integration/    # May require dbt, real files\n\u2514\u2500\u2500 e2e/           # Full dbt execution\n</code></pre>"},{"location":"developer-guide/testing/#test-categories","title":"Test Categories","text":""},{"location":"developer-guide/testing/#unit-tests-testsunit","title":"Unit Tests (<code>tests/unit/</code>)","text":"<p>Fast tests with no external dependencies: - Model validation - Pure functions - Mocked I/O</p> <pre><code>uv run poe test-unit\n</code></pre> <p>Example:</p> <pre><code>from brix.modules.dbt.profile.models import DuckDbOutput\n\ndef test_duckdb_output_defaults():\n    output = DuckDbOutput(path=\"./test.duckdb\")\n    assert output.type == \"duckdb\"\n    assert output.threads == 4  # default\n</code></pre>"},{"location":"developer-guide/testing/#integration-tests-testsintegration","title":"Integration Tests (<code>tests/integration/</code>)","text":"<p>Tests requiring real file operations or dbt: - File creation/modification - YAML parsing - Template rendering</p> <pre><code>uv run poe test-integration\n</code></pre> <p>Mark with <code>@pytest.mark.integration</code>:</p> <pre><code>import pytest\nfrom pathlib import Path\n\n@pytest.mark.integration\ndef test_profile_yaml_creation(tmp_path: Path):\n    from brix.modules.dbt.profile.service import init_profile\n\n    result = init_profile(tmp_path / \"profiles.yml\")\n    assert result.success\n    assert (tmp_path / \"profiles.yml\").exists()\n</code></pre>"},{"location":"developer-guide/testing/#e2e-tests-testse2e","title":"E2E Tests (<code>tests/e2e/</code>)","text":"<p>Full workflow tests with real dbt execution: - Project initialization - dbt command passthrough - Complete user workflows</p> <pre><code>uv run poe test-e2e\n</code></pre> <p>Mark with <code>@pytest.mark.e2e</code>:</p> <pre><code>import pytest\nimport subprocess\n\n@pytest.mark.e2e\ndef test_dbt_run_passthrough(tmp_path: Path, initialized_project):\n    result = subprocess.run(\n        [\"brix\", \"dbt\", \"-p\", str(initialized_project), \"debug\"],\n        capture_output=True,\n        text=True,\n    )\n    assert result.returncode == 0\n</code></pre>"},{"location":"developer-guide/testing/#running-tests","title":"Running Tests","text":""},{"location":"developer-guide/testing/#all-tests","title":"All Tests","text":"<pre><code>uv run poe test\n</code></pre>"},{"location":"developer-guide/testing/#specific-category","title":"Specific Category","text":"<pre><code>uv run poe test-unit\nuv run poe test-integration\nuv run poe test-e2e\n</code></pre>"},{"location":"developer-guide/testing/#specific-file","title":"Specific File","text":"<pre><code>uv run pytest tests/unit/test_profile_models.py -v\n</code></pre>"},{"location":"developer-guide/testing/#specific-test","title":"Specific Test","text":"<pre><code>uv run pytest tests/unit/test_profile_models.py::test_duckdb_output -v\n</code></pre>"},{"location":"developer-guide/testing/#with-coverage","title":"With Coverage","text":"<pre><code>uv run pytest --cov=brix --cov-report=html\n# Open htmlcov/index.html\n</code></pre>"},{"location":"developer-guide/testing/#verbose-output","title":"Verbose Output","text":"<pre><code>uv run pytest -v --tb=long\n</code></pre>"},{"location":"developer-guide/testing/#fixtures","title":"Fixtures","text":""},{"location":"developer-guide/testing/#common-fixtures","title":"Common Fixtures","text":"<pre><code># conftest.py\nimport pytest\nfrom pathlib import Path\n\n@pytest.fixture\ndef tmp_profiles(tmp_path: Path) -&gt; Path:\n    \"\"\"Create temporary profiles.yml.\"\"\"\n    profiles_path = tmp_path / \"profiles.yml\"\n    profiles_path.write_text(\"\"\"\ndefault:\n  target: dev\n  outputs:\n    dev:\n      type: duckdb\n      path: ./dev.duckdb\n\"\"\")\n    return profiles_path\n\n@pytest.fixture\ndef tmp_project(tmp_path: Path) -&gt; Path:\n    \"\"\"Create temporary dbt project.\"\"\"\n    project_path = tmp_path / \"test_project\"\n    project_path.mkdir()\n    (project_path / \"dbt_project.yml\").write_text(\"\"\"\nname: test_project\nversion: '1.0.0'\nprofile: default\n\"\"\")\n    return project_path\n</code></pre>"},{"location":"developer-guide/testing/#mocking","title":"Mocking","text":"<pre><code>from unittest.mock import patch, MagicMock\n\ndef test_version_check_disabled():\n    with patch(\"brix.version_check.httpx.get\") as mock_get:\n        mock_get.side_effect = Exception(\"Network error\")\n        # Version check should fail silently\n        from brix.version_check import check_version\n        result = check_version()\n        assert result is None  # No crash\n</code></pre>"},{"location":"developer-guide/testing/#test-patterns","title":"Test Patterns","text":""},{"location":"developer-guide/testing/#testing-cli-commands","title":"Testing CLI Commands","text":"<pre><code>from typer.testing import CliRunner\nfrom brix.main import app\n\nrunner = CliRunner()\n\ndef test_version_flag():\n    result = runner.invoke(app, [\"--version\"])\n    assert result.exit_code == 0\n    assert \"brix\" in result.output\n\ndef test_profile_init(tmp_path: Path):\n    result = runner.invoke(app, [\n        \"dbt\", \"profile\", \"init\",\n        \"--profile-path\", str(tmp_path / \"profiles.yml\"),\n    ])\n    assert result.exit_code == 0\n</code></pre>"},{"location":"developer-guide/testing/#testing-interactive-prompts","title":"Testing Interactive Prompts","text":"<pre><code>from unittest.mock import patch\n\ndef test_interactive_profile_edit():\n    with patch(\"questionary.select\") as mock_select:\n        mock_select.return_value.ask.return_value = \"add-profile\"\n        # Test prompt behavior\n</code></pre>"},{"location":"developer-guide/testing/#testing-pydantic-models","title":"Testing Pydantic Models","text":"<pre><code>import pytest\nfrom pydantic import ValidationError\n\ndef test_required_field_validation():\n    with pytest.raises(ValidationError):\n        DatabricksOutput()  # Missing required fields\n\ndef test_discriminated_union():\n    from pydantic import TypeAdapter\n    adapter = TypeAdapter(OutputConfig)\n\n    duckdb_data = {\"type\": \"duckdb\", \"path\": \"./test.db\"}\n    result = adapter.validate_python(duckdb_data)\n    assert isinstance(result, DuckDbOutput)\n</code></pre>"},{"location":"developer-guide/testing/#testing-file-operations","title":"Testing File Operations","text":"<pre><code>@pytest.mark.integration\ndef test_yaml_roundtrip(tmp_path: Path):\n    original = DbtProfiles(profiles={\"test\": {...}})\n    yaml_path = tmp_path / \"profiles.yml\"\n\n    # Write\n    yaml_path.write_text(original.to_yaml())\n\n    # Read back\n    loaded = DbtProfiles.from_yaml(yaml_path.read_text())\n\n    assert loaded == original\n</code></pre>"},{"location":"developer-guide/testing/#debugging-tests","title":"Debugging Tests","text":""},{"location":"developer-guide/testing/#print-output","title":"Print Output","text":"<pre><code>uv run pytest -v -s  # -s shows print statements\n</code></pre>"},{"location":"developer-guide/testing/#stop-on-first-failure","title":"Stop on First Failure","text":"<pre><code>uv run pytest -x\n</code></pre>"},{"location":"developer-guide/testing/#drop-into-debugger","title":"Drop into Debugger","text":"<pre><code>uv run pytest --pdb\n</code></pre> <p>Or in code:</p> <pre><code>def test_something():\n    import pdb; pdb.set_trace()\n    # ...\n</code></pre>"},{"location":"developer-guide/testing/#show-local-variables","title":"Show Local Variables","text":"<pre><code>uv run pytest -l --tb=long\n</code></pre>"},{"location":"developer-guide/testing/#cicd-integration","title":"CI/CD Integration","text":"<p>Tests run automatically on: - Pull requests - Pushes to main</p> <p>GitHub Actions workflow runs: 1. <code>uv run poe lint</code> 2. <code>uv run poe typecheck</code> 3. <code>uv run poe test</code></p> <p>See <code>.github/workflows/ci.yml</code> for configuration.</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> <li>pip, uv, or pipx for installation</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":"<pre><code>pip install brix\n</code></pre>"},{"location":"getting-started/installation/#using-uv-recommended","title":"Using uv (Recommended)","text":"<p>uv is a fast Python package manager:</p> <pre><code># Install as a tool (isolated environment)\nuv tool install brix\n\n# Or add to a project\nuv add brix\n</code></pre>"},{"location":"getting-started/installation/#using-pipx","title":"Using pipx","text":"<p>For isolated installation:</p> <pre><code>pipx install brix\n</code></pre>"},{"location":"getting-started/installation/#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/Spycner/brix.git\ncd brix\nuv sync\nuv run brix --help\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<pre><code>brix --version\n</code></pre> <p>You should see output like:</p> <pre><code>brix 1.2.0\n</code></pre>"},{"location":"getting-started/installation/#shell-completion","title":"Shell Completion","text":"<p>Brix supports shell completion for bash, zsh, and fish.</p>"},{"location":"getting-started/installation/#install-completion","title":"Install Completion","text":"<pre><code>brix --install-completion\n</code></pre>"},{"location":"getting-started/installation/#show-completion-script","title":"Show Completion Script","text":"<pre><code>brix --show-completion\n</code></pre>"},{"location":"getting-started/installation/#upgrading","title":"Upgrading","text":""},{"location":"getting-started/installation/#pip","title":"pip","text":"<pre><code>pip install --upgrade brix\n</code></pre>"},{"location":"getting-started/installation/#uv","title":"uv","text":"<pre><code>uv tool upgrade brix\n</code></pre>"},{"location":"getting-started/installation/#pipx","title":"pipx","text":"<pre><code>pipx upgrade brix\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Follow the Quick Start guide to create your first project</li> <li>Read the Commands Overview for all available commands</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide will help you get started with brix in just a few minutes.</p>"},{"location":"getting-started/quickstart/#step-1-initialize-a-profile","title":"Step 1: Initialize a Profile","text":"<p>Before creating a dbt project, you need a profile configuration. Brix can initialize one for you:</p> <pre><code>brix dbt profile init\n</code></pre> <p>This creates a <code>profiles.yml</code> at <code>~/.dbt/profiles.yml</code> with a DuckDB configuration for local development.</p> <p>Custom Location</p> <p>Specify a custom path with <code>--profile-path</code>: <pre><code>brix dbt profile init --profile-path ./profiles.yml\n</code></pre></p>"},{"location":"getting-started/quickstart/#step-2-create-a-project","title":"Step 2: Create a Project","text":"<p>Create a new dbt project with the interactive wizard:</p> <pre><code>brix dbt project init\n</code></pre> <p>The wizard will guide you through:</p> <ol> <li>Project name - Name for your dbt project</li> <li>Profile selection - Which profile to use</li> <li>Packages - Add common packages (dbt_utils, elementary, etc.)</li> <li>Databricks settings - Materialization and documentation options</li> <li>Example model - Generate a sample model to get started</li> </ol> <p>Non-Interactive Mode</p> <p>For scripting, use CLI flags: <pre><code>brix dbt project init --project-name my_project --profile default\n</code></pre></p>"},{"location":"getting-started/quickstart/#step-3-run-dbt-commands","title":"Step 3: Run dbt Commands","text":"<p>Brix passes through any dbt command:</p> <pre><code># Install packages\nbrix dbt deps\n\n# Run models\nbrix dbt run\n\n# Test models\nbrix dbt test\n\n# Generate documentation\nbrix dbt docs generate\nbrix dbt docs serve\n</code></pre>"},{"location":"getting-started/quickstart/#common-workflows","title":"Common Workflows","text":""},{"location":"getting-started/quickstart/#local-development-with-duckdb","title":"Local Development with DuckDB","text":"<pre><code># Initialize profile with DuckDB\nbrix dbt profile init\n\n# Create project\nbrix dbt project init\n\n# Run locally\nbrix dbt run\n</code></pre>"},{"location":"getting-started/quickstart/#add-a-databricks-connection","title":"Add a Databricks Connection","text":"<pre><code># Edit profile to add Databricks\nbrix dbt profile edit\n\n# Select \"Add new output\"\n# Choose \"databricks\" adapter\n# Configure authentication (OAuth or Personal Access Token)\n</code></pre>"},{"location":"getting-started/quickstart/#manage-packages","title":"Manage Packages","text":"<pre><code># Add a package from dbt Hub\nbrix dbt project edit --action add-hub-package\n\n# Or non-interactively\nbrix dbt project edit --action add-hub-package --package-name dbt_utils --package-version \"&gt;=1.0.0\"\n\n# Install packages\nbrix dbt deps\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Commands Overview - Full command reference</li> <li>Profile Management - Deep dive into profiles</li> <li>Project Management - Advanced project configuration</li> <li>Configuration - Environment variables and settings</li> </ul>"},{"location":"user-guide/commands/","title":"Commands Overview","text":"<p>Brix provides a hierarchical command structure centered around dbt operations.</p>"},{"location":"user-guide/commands/#command-structure","title":"Command Structure","text":"<pre><code>brix [global-options] dbt [dbt-options] [subcommand] [args]\n</code></pre>"},{"location":"user-guide/commands/#global-options","title":"Global Options","text":"Option Short Description <code>--version</code> <code>-v</code> Show version and exit <code>--log-level</code> Log level: TRACE, DEBUG, INFO, WARN, ERROR, OFF <code>--log-path</code> File path for log output <code>--log-json</code> Enable JSON log format <code>--install-completion</code> Install shell completion <code>--show-completion</code> Show shell completion script <code>--help</code> <code>-h</code> Show help message"},{"location":"user-guide/commands/#command-groups","title":"Command Groups","text":""},{"location":"user-guide/commands/#brix-dbt","title":"<code>brix dbt</code>","text":"<p>Main command group for dbt operations.</p> Option Short Description <code>--project</code> <code>-p</code> Path to dbt project directory (cached for subsequent commands)"},{"location":"user-guide/commands/#subcommands","title":"Subcommands","text":"Command Description <code>profile</code> Manage dbt profile configuration <code>project</code> Manage dbt projects any dbt command Passed through to dbt CLI"},{"location":"user-guide/commands/#brix-dbt-profile","title":"<code>brix dbt profile</code>","text":"<p>Manage <code>profiles.yml</code> configuration.</p> Command Description <code>init</code> Initialize a dbt profile from template <code>show</code> Show the current profile path and contents <code>edit</code> Edit profile configuration (interactive or CLI)"},{"location":"user-guide/commands/#brix-dbt-project","title":"<code>brix dbt project</code>","text":"<p>Manage dbt projects.</p> Command Description <code>init</code> Initialize a new dbt project <code>edit</code> Edit project configuration"},{"location":"user-guide/commands/#quick-reference","title":"Quick Reference","text":""},{"location":"user-guide/commands/#profile-commands","title":"Profile Commands","text":"<pre><code># Initialize profile\nbrix dbt profile init\nbrix dbt profile init --profile-path ./profiles.yml --force\n\n# View profile\nbrix dbt profile show\n\n# Edit profile (interactive)\nbrix dbt profile edit\n\n# Edit profile (CLI)\nbrix dbt profile edit --action add-profile --profile myproj --target dev\nbrix dbt profile edit --action delete-profile --profile old --force\n</code></pre>"},{"location":"user-guide/commands/#project-commands","title":"Project Commands","text":"<pre><code># Create project (interactive)\nbrix dbt project init\n\n# Create project (CLI)\nbrix dbt project init -n my_project -p default --materialization table\n\n# Edit project (interactive)\nbrix dbt project edit\n\n# Edit project (CLI)\nbrix dbt project edit -p ./dbt_project.yml --action set-name --name new_name\nbrix dbt project edit --action add-hub-package --package dbt_utils\n</code></pre>"},{"location":"user-guide/commands/#dbt-passthrough","title":"dbt Passthrough","text":"<pre><code># Any dbt command works\nbrix dbt run\nbrix dbt test\nbrix dbt build\nbrix dbt docs generate\nbrix dbt docs serve\nbrix dbt seed\nbrix dbt snapshot\n</code></pre>"},{"location":"user-guide/commands/#detailed-command-reference","title":"Detailed Command Reference","text":"<ul> <li>Profile Management - Complete profile command reference</li> <li>Project Management - Complete project command reference</li> <li>dbt Passthrough - Using native dbt commands</li> </ul>"},{"location":"user-guide/configuration/","title":"Configuration","text":"<p>Brix uses environment variables and CLI options for configuration.</p>"},{"location":"user-guide/configuration/#configuration-precedence","title":"Configuration Precedence","text":"<ol> <li>CLI arguments - Highest priority</li> <li>Environment variables - Override defaults</li> <li>Defaults - Built-in values</li> </ol>"},{"location":"user-guide/configuration/#environment-variables","title":"Environment Variables","text":""},{"location":"user-guide/configuration/#profile-configuration","title":"Profile Configuration","text":"Variable Default Description <code>BRIX_DBT_PROFILE_PATH</code> <code>~/.dbt/profiles.yml</code> Path to dbt profiles.yml"},{"location":"user-guide/configuration/#project-configuration","title":"Project Configuration","text":"Variable Default Description <code>BRIX_DBT_PROJECT_BASE_DIR</code> <code>.</code> Base directory for new projects"},{"location":"user-guide/configuration/#logging-configuration","title":"Logging Configuration","text":"Variable Default Description <code>BRIX_LOG</code> <code>OFF</code> Log level: TRACE, DEBUG, INFO, WARN, ERROR, OFF <code>BRIX_LOG_PATH</code> File path for log output <code>BRIX_LOG_JSON</code> <code>false</code> Enable JSON log format"},{"location":"user-guide/configuration/#cli-options","title":"CLI Options","text":""},{"location":"user-guide/configuration/#global-options","title":"Global Options","text":"<pre><code>brix --log-level DEBUG dbt run\nbrix --log-path ./brix.log dbt test\nbrix --log-json dbt build\n</code></pre>"},{"location":"user-guide/configuration/#profile-options","title":"Profile Options","text":"<pre><code>brix dbt profile init --profile-path ./profiles.yml\nbrix dbt profile edit -p ./profiles.yml\n</code></pre>"},{"location":"user-guide/configuration/#project-options","title":"Project Options","text":"<pre><code>brix dbt -p ./my_project run\nbrix dbt project init --base-dir ./projects\n</code></pre>"},{"location":"user-guide/configuration/#cache-locations","title":"Cache Locations","text":"<p>Brix stores cache files in <code>~/.cache/brix/</code>:</p> File Purpose <code>dbt_project_path.json</code> Last used project path <code>version_check.json</code> Version check results (24-hour TTL)"},{"location":"user-guide/configuration/#logging","title":"Logging","text":"<p>Brix uses Terraform-style logging with customizable output.</p>"},{"location":"user-guide/configuration/#log-levels","title":"Log Levels","text":"Level Description <code>TRACE</code> Most verbose, debugging internals <code>DEBUG</code> Detailed debugging information <code>INFO</code> General operational information <code>WARN</code> Warning messages <code>ERROR</code> Error messages only <code>OFF</code> Disable logging (default)"},{"location":"user-guide/configuration/#examples","title":"Examples","text":"<p>Console logging:</p> <pre><code>BRIX_LOG=DEBUG brix dbt run\n</code></pre> <p>File logging:</p> <pre><code>BRIX_LOG=INFO BRIX_LOG_PATH=./brix.log brix dbt run\n</code></pre> <p>JSON logging:</p> <pre><code>BRIX_LOG=DEBUG BRIX_LOG_JSON=true brix dbt run\n</code></pre> <p>Via CLI:</p> <pre><code>brix --log-level DEBUG --log-path ./debug.log dbt run\n</code></pre>"},{"location":"user-guide/configuration/#version-checking","title":"Version Checking","text":"<p>Brix checks for updates in the background:</p> <ul> <li>Runs in a non-blocking background thread</li> <li>Results cached for 24 hours</li> <li>Shows notification if a newer version is available</li> <li>Never blocks command execution</li> </ul> <p>To disable version checks, the feature fails silently if network is unavailable.</p>"},{"location":"user-guide/configuration/#example-production-setup","title":"Example: Production Setup","text":"<pre><code># .env file\nexport BRIX_DBT_PROFILE_PATH=/etc/dbt/profiles.yml\nexport BRIX_DBT_PROJECT_BASE_DIR=/var/dbt/projects\nexport BRIX_LOG=INFO\nexport BRIX_LOG_PATH=/var/log/brix/brix.log\nexport BRIX_LOG_JSON=true\n</code></pre>"},{"location":"user-guide/configuration/#example-development-setup","title":"Example: Development Setup","text":"<pre><code># Development .env\nexport BRIX_LOG=DEBUG\nexport BRIX_DBT_PROFILE_PATH=./profiles.yml\n</code></pre>"},{"location":"user-guide/configuration/#shell-completion","title":"Shell Completion","text":"<p>Enable tab completion for faster command entry:</p> <pre><code># Install completion for your shell\nbrix --install-completion\n\n# View completion script\nbrix --show-completion\n</code></pre> <p>Supported shells: - bash - zsh - fish - PowerShell</p>"},{"location":"user-guide/passthrough/","title":"dbt Passthrough","text":"<p>Brix transparently passes through any dbt command that isn't a built-in brix command.</p>"},{"location":"user-guide/passthrough/#how-it-works","title":"How It Works","text":"<p>When you run a command like <code>brix dbt run</code>, brix checks if <code>run</code> is a built-in subcommand. Since it isn't, brix passes the command directly to the dbt CLI.</p> <pre><code>brix dbt run        # Executes: dbt run\nbrix dbt test       # Executes: dbt test\nbrix dbt build      # Executes: dbt build\n</code></pre>"},{"location":"user-guide/passthrough/#project-path-caching","title":"Project Path Caching","text":"<p>Brix caches the project path for convenience. When you specify a project once, subsequent commands use the same path:</p> <pre><code># First command sets the project path\nbrix dbt -p ./my_project run\n\n# Subsequent commands use the cached path\nbrix dbt test\nbrix dbt docs generate\n</code></pre> <p>The cache is stored in <code>~/.cache/brix/dbt_project_path.json</code>.</p> <p>To use a different project:</p> <pre><code>brix dbt -p ./other_project run\n</code></pre>"},{"location":"user-guide/passthrough/#common-dbt-commands","title":"Common dbt Commands","text":""},{"location":"user-guide/passthrough/#model-execution","title":"Model Execution","text":"<pre><code># Run all models\nbrix dbt run\n\n# Run specific model\nbrix dbt run --select my_model\n\n# Run models with tags\nbrix dbt run --select tag:daily\n\n# Full refresh incremental models\nbrix dbt run --full-refresh\n</code></pre>"},{"location":"user-guide/passthrough/#testing","title":"Testing","text":"<pre><code># Run all tests\nbrix dbt test\n\n# Test specific model\nbrix dbt test --select my_model\n\n# Run only data tests\nbrix dbt test --select test_type:data\n\n# Run only schema tests\nbrix dbt test --select test_type:schema\n</code></pre>"},{"location":"user-guide/passthrough/#build","title":"Build","text":"<pre><code># Run + test in dependency order\nbrix dbt build\n\n# Build specific models\nbrix dbt build --select staging.*\n</code></pre>"},{"location":"user-guide/passthrough/#seeds","title":"Seeds","text":"<pre><code># Load all seed files\nbrix dbt seed\n\n# Load specific seed\nbrix dbt seed --select countries\n</code></pre>"},{"location":"user-guide/passthrough/#snapshots","title":"Snapshots","text":"<pre><code># Run all snapshots\nbrix dbt snapshot\n\n# Run specific snapshot\nbrix dbt snapshot --select orders_snapshot\n</code></pre>"},{"location":"user-guide/passthrough/#documentation","title":"Documentation","text":"<pre><code># Generate docs\nbrix dbt docs generate\n\n# Serve docs locally\nbrix dbt docs serve\n\n# Serve on specific port\nbrix dbt docs serve --port 8080\n</code></pre>"},{"location":"user-guide/passthrough/#dependencies","title":"Dependencies","text":"<pre><code># Install packages\nbrix dbt deps\n</code></pre>"},{"location":"user-guide/passthrough/#debugging","title":"Debugging","text":"<pre><code># Debug configuration\nbrix dbt debug\n\n# Show compiled SQL\nbrix dbt compile --select my_model\n\n# List resources\nbrix dbt ls\nbrix dbt ls --select tag:pii\n</code></pre>"},{"location":"user-guide/passthrough/#source-management","title":"Source Management","text":"<pre><code># Check source freshness\nbrix dbt source freshness\n</code></pre>"},{"location":"user-guide/passthrough/#passing-arguments","title":"Passing Arguments","text":"<p>All dbt arguments work as expected:</p> <pre><code># Multiple selectors\nbrix dbt run --select model1 model2\n\n# Exclude models\nbrix dbt run --exclude staging.*\n\n# Set variables\nbrix dbt run --vars '{\"start_date\": \"2024-01-01\"}'\n\n# Target specific environment\nbrix dbt run --target prod\n\n# Thread count\nbrix dbt run --threads 8\n\n# Fail fast\nbrix dbt run --fail-fast\n</code></pre>"},{"location":"user-guide/passthrough/#environment-variables","title":"Environment Variables","text":"<p>dbt environment variables work normally:</p> <pre><code>export DBT_PROFILES_DIR=./custom_profiles\nexport DBT_TARGET=production\n\nbrix dbt run\n</code></pre>"},{"location":"user-guide/passthrough/#limitations","title":"Limitations","text":"<ul> <li>The project path cache is per-user, not per-terminal session</li> <li>brix-specific options (<code>--log-level</code>, etc.) must come before <code>dbt</code></li> </ul> <pre><code># Correct\nbrix --log-level DEBUG dbt run\n\n# Also correct\nbrix dbt -p ./project run --select my_model\n</code></pre>"},{"location":"user-guide/profiles/","title":"Profile Management","text":"<p>Brix provides commands to initialize, view, and edit dbt profile configurations (<code>profiles.yml</code>).</p>"},{"location":"user-guide/profiles/#overview","title":"Overview","text":"<p>dbt profiles define connection information for your data warehouses. Brix simplifies profile management with:</p> <ul> <li>Templates - Quick initialization with sensible defaults</li> <li>Interactive editing - Menu-driven configuration</li> <li>CLI mode - Scriptable, non-interactive operations</li> <li>Multiple adapters - DuckDB for local dev, Databricks for production</li> </ul>"},{"location":"user-guide/profiles/#commands","title":"Commands","text":""},{"location":"user-guide/profiles/#brix-dbt-profile-init","title":"<code>brix dbt profile init</code>","text":"<p>Initialize a dbt profile from template.</p> <pre><code>brix dbt profile init [OPTIONS]\n</code></pre>"},{"location":"user-guide/profiles/#options","title":"Options","text":"Option Short Default Description <code>--profile-path</code> <code>-p</code> <code>~/.dbt/profiles.yml</code> Path to profiles.yml <code>--force</code> <code>-f</code> Overwrite existing profile"},{"location":"user-guide/profiles/#environment-variables","title":"Environment Variables","text":"Variable Description <code>BRIX_DBT_PROFILE_PATH</code> Default path for profiles.yml"},{"location":"user-guide/profiles/#examples","title":"Examples","text":"<pre><code># Initialize at default location\nbrix dbt profile init\n\n# Initialize at custom location\nbrix dbt profile init --profile-path ./profiles.yml\n\n# Overwrite existing\nbrix dbt profile init --force\n</code></pre> <p>The template includes a DuckDB configuration:</p> <pre><code>default:\n  target: dev\n  outputs:\n    dev:\n      type: duckdb\n      path: ./dev.duckdb\n</code></pre>"},{"location":"user-guide/profiles/#brix-dbt-profile-show","title":"<code>brix dbt profile show</code>","text":"<p>Display the current profile path and contents.</p> <pre><code>brix dbt profile show\n</code></pre> <p>Shows: - Profile file path - Full YAML contents</p>"},{"location":"user-guide/profiles/#brix-dbt-profile-edit","title":"<code>brix dbt profile edit</code>","text":"<p>Edit dbt profile configuration.</p> <pre><code>brix dbt profile edit [OPTIONS]\n</code></pre>"},{"location":"user-guide/profiles/#options_1","title":"Options","text":"Option Short Description <code>--profile-path</code> <code>-p</code> Path to profiles.yml <code>--action</code> <code>-a</code> Action to perform (see below) <code>--profile</code> <code>-P</code> Profile name <code>--output</code> <code>-o</code> Output name <code>--target</code> <code>-t</code> Default target name <code>--path</code> DuckDB path <code>--threads</code> Thread count <code>--force</code> <code>-f</code> Skip confirmation for destructive actions"},{"location":"user-guide/profiles/#actions","title":"Actions","text":"Action Description <code>add-profile</code> Add a new profile <code>edit-profile</code> Edit existing profile settings <code>delete-profile</code> Remove a profile <code>add-output</code> Add output to a profile <code>edit-output</code> Edit an existing output <code>delete-output</code> Remove an output"},{"location":"user-guide/profiles/#interactive-mode","title":"Interactive Mode","text":"<p>Without <code>--action</code>, launches an interactive menu:</p> <pre><code>brix dbt profile edit\n</code></pre> <p>The menu provides:</p> <ol> <li>Select profile to edit</li> <li>Choose action (add/edit/delete profile or output)</li> <li>Configure settings via prompts</li> </ol>"},{"location":"user-guide/profiles/#cli-mode-examples","title":"CLI Mode Examples","text":"<pre><code># Add a new profile\nbrix dbt profile edit --action add-profile --profile myproject --target dev\n\n# Edit profile target\nbrix dbt profile edit --action edit-profile --profile default --target prod\n\n# Delete profile (with confirmation skip)\nbrix dbt profile edit --action delete-profile --profile old --force\n\n# Add DuckDB output\nbrix dbt profile edit --action add-output --profile default --output local \\\n  --path ./local.duckdb --threads 4\n\n# Edit existing output\nbrix dbt profile edit --action edit-output --profile default --output dev \\\n  --path ./new.duckdb\n\n# Delete output\nbrix dbt profile edit --action delete-output --profile default --output old --force\n</code></pre>"},{"location":"user-guide/profiles/#supported-adapters","title":"Supported Adapters","text":""},{"location":"user-guide/profiles/#duckdb","title":"DuckDB","text":"<p>For local development and testing.</p> <pre><code>outputs:\n  dev:\n    type: duckdb\n    path: ./dev.duckdb\n    threads: 4\n    extensions:\n      - httpfs\n      - parquet\n    settings:\n      memory_limit: 4GB\n</code></pre> <p>Configuration options: - <code>path</code> - Database file path (<code>:memory:</code> for in-memory) - <code>threads</code> - Number of threads - <code>extensions</code> - DuckDB extensions to load - <code>settings</code> - DuckDB configuration settings</p>"},{"location":"user-guide/profiles/#databricks","title":"Databricks","text":"<p>For production workloads on Databricks.</p>"},{"location":"user-guide/profiles/#oauth-user-to-machine-u2m","title":"OAuth User-to-Machine (U2M)","text":"<pre><code>outputs:\n  prod:\n    type: databricks\n    host: dbc-abc123.cloud.databricks.com\n    http_path: /sql/1.0/warehouses/xyz789\n    catalog: main\n    schema: analytics\n    auth_type: oauth-u2m\n</code></pre>"},{"location":"user-guide/profiles/#oauth-machine-to-machine-m2m","title":"OAuth Machine-to-Machine (M2M)","text":"<pre><code>outputs:\n  prod:\n    type: databricks\n    host: dbc-abc123.cloud.databricks.com\n    http_path: /sql/1.0/warehouses/xyz789\n    catalog: main\n    schema: analytics\n    auth_type: oauth-m2m\n    client_id: \"{{ env_var('DBT_DATABRICKS_CLIENT_ID') }}\"\n    client_secret: \"{{ env_var('DBT_DATABRICKS_CLIENT_SECRET') }}\"\n</code></pre>"},{"location":"user-guide/profiles/#personal-access-token-pat","title":"Personal Access Token (PAT)","text":"<pre><code>outputs:\n  prod:\n    type: databricks\n    host: dbc-abc123.cloud.databricks.com\n    http_path: /sql/1.0/warehouses/xyz789\n    catalog: main\n    schema: analytics\n    token: \"{{ env_var('DBT_DATABRICKS_TOKEN') }}\"\n</code></pre>"},{"location":"user-guide/profiles/#best-practices","title":"Best Practices","text":"<ol> <li>Use environment variables for sensitive values like tokens</li> <li>Keep local dev profiles using DuckDB for fast iteration</li> <li>Separate targets for dev, staging, and production</li> <li>Use OAuth when possible for better security on Databricks</li> </ol>"},{"location":"user-guide/projects/","title":"Project Management","text":"<p>Brix provides commands to create and edit dbt projects with sensible defaults and package management.</p>"},{"location":"user-guide/projects/#overview","title":"Overview","text":"<ul> <li>Project scaffolding - Create complete dbt projects with one command</li> <li>Package management - Add packages from dbt Hub, Git, or local paths</li> <li>Interactive wizard - Guided setup for new projects</li> <li>CLI mode - Fully scriptable project creation and modification</li> </ul>"},{"location":"user-guide/projects/#commands","title":"Commands","text":""},{"location":"user-guide/projects/#brix-dbt-project-init","title":"<code>brix dbt project init</code>","text":"<p>Initialize a new dbt project with sensible defaults.</p> <pre><code>brix dbt project init [OPTIONS]\n</code></pre>"},{"location":"user-guide/projects/#options","title":"Options","text":"Option Short Default Description <code>--project-name</code> <code>-n</code> Name of the dbt project (interactive if not provided) <code>--base-dir</code> <code>-b</code> <code>.</code> Base directory for project <code>--team</code> <code>-t</code> Team subdirectory (optional) <code>--profile</code> <code>-p</code> Profile name to use <code>--profile-path</code> <code>~/.dbt/profiles.yml</code> Path to profiles.yml for validation <code>--packages</code> Packages to include (can repeat) <code>--no-packages</code> Skip package installation <code>--materialization</code> Default: view, table, or ephemeral <code>--persist-docs</code> Enable persist_docs for Unity Catalog <code>--run-deps</code> Run <code>dbt deps</code> after creation <code>--with-example</code> Create example model <code>--force</code> <code>-f</code> Overwrite existing project"},{"location":"user-guide/projects/#environment-variables","title":"Environment Variables","text":"Variable Description <code>BRIX_DBT_PROJECT_BASE_DIR</code> Default base directory <code>BRIX_DBT_PROFILE_PATH</code> Default profiles.yml path"},{"location":"user-guide/projects/#interactive-mode","title":"Interactive Mode","text":"<p>Without <code>--project-name</code>, launches a wizard:</p> <pre><code>brix dbt project init\n</code></pre> <p>The wizard guides you through:</p> <ol> <li>Project name - Validates naming conventions</li> <li>Team directory - Optional subdirectory organization</li> <li>Profile selection - Lists available profiles</li> <li>Packages - Select from common packages or enter custom</li> <li>Databricks settings - Materialization and persist_docs</li> <li>Example model - Generate a sample model</li> </ol>"},{"location":"user-guide/projects/#cli-mode-examples","title":"CLI Mode Examples","text":"<pre><code># Minimal project\nbrix dbt project init -n my_project\n\n# Full configuration\nbrix dbt project init \\\n  --project-name analytics \\\n  --base-dir ./projects \\\n  --team data-engineering \\\n  --profile production \\\n  --packages dbt_utils \\\n  --packages elementary \\\n  --materialization table \\\n  --persist-docs \\\n  --run-deps \\\n  --with-example\n\n# Overwrite existing\nbrix dbt project init -n my_project --force\n</code></pre>"},{"location":"user-guide/projects/#generated-structure","title":"Generated Structure","text":"<pre><code>my_project/\n\u251c\u2500\u2500 dbt_project.yml\n\u251c\u2500\u2500 packages.yml\n\u251c\u2500\u2500 models/\n\u2502   \u2514\u2500\u2500 example/\n\u2502       \u251c\u2500\u2500 example_model.sql\n\u2502       \u2514\u2500\u2500 schema.yml\n\u251c\u2500\u2500 seeds/\n\u251c\u2500\u2500 macros/\n\u251c\u2500\u2500 snapshots/\n\u251c\u2500\u2500 tests/\n\u2514\u2500\u2500 .gitignore\n</code></pre>"},{"location":"user-guide/projects/#brix-dbt-project-edit","title":"<code>brix dbt project edit</code>","text":"<p>Edit dbt project configuration.</p> <pre><code>brix dbt project edit [OPTIONS]\n</code></pre>"},{"location":"user-guide/projects/#options_1","title":"Options","text":"Option Short Description <code>--project</code> <code>-p</code> Path to dbt_project.yml <code>--action</code> <code>-a</code> Action to perform <code>--name</code> New project name <code>--profile</code> New profile name <code>--version</code> <code>-v</code> New project version <code>--require-dbt-version</code> dbt version constraint <code>--path-field</code> Path field to modify <code>--path</code> Path value <code>--create-dir</code> Create directory when adding path <code>--package</code> Package name <code>--package-version</code> Package version specifier <code>--revision</code> Git revision <code>--subdirectory</code> Subdirectory in git repo <code>--force</code> <code>-f</code> Skip confirmations"},{"location":"user-guide/projects/#actions","title":"Actions","text":"<p>Project Settings:</p> Action Description <code>set-name</code> Change project name <code>set-profile</code> Change profile reference <code>set-version</code> Change project version <code>set-require-dbt-version</code> Set dbt version constraint <p>Path Management:</p> Action Description <code>add-path</code> Add to path arrays (model-paths, seed-paths, etc.) <code>remove-path</code> Remove from path arrays <p>Package Management:</p> Action Description <code>add-hub-package</code> Add package from dbt Hub <code>add-git-package</code> Add package from Git repository <code>add-local-package</code> Add local package <code>remove-package</code> Remove a package <code>update-package-version</code> Update package version"},{"location":"user-guide/projects/#interactive-mode_1","title":"Interactive Mode","text":"<p>Without <code>--action</code>, launches interactive editor:</p> <pre><code>brix dbt project edit\n</code></pre> <p>Features: - Project discovery (finds dbt_project.yml in current directory tree) - Menu-driven action selection - Guided prompts for each action</p>"},{"location":"user-guide/projects/#cli-mode-examples_1","title":"CLI Mode Examples","text":"<p>Project Settings:</p> <pre><code># Change project name\nbrix dbt project edit -p ./dbt_project.yml --action set-name --name new_name\n\n# Change profile\nbrix dbt project edit --action set-profile --profile production\n\n# Set version\nbrix dbt project edit --action set-version --version 2.0.0\n\n# Set dbt version constraint\nbrix dbt project edit --action set-require-dbt-version --require-dbt-version \"&gt;=1.7.0\"\n</code></pre> <p>Path Management:</p> <pre><code># Add model path with directory creation\nbrix dbt project edit --action add-path \\\n  --path-field model-paths \\\n  --path staging \\\n  --create-dir\n\n# Remove seed path\nbrix dbt project edit --action remove-path \\\n  --path-field seed-paths \\\n  --path old_seeds\n</code></pre> <p>Package Management:</p> <pre><code># Add dbt Hub package\nbrix dbt project edit --action add-hub-package \\\n  --package dbt-labs/dbt_utils \\\n  --package-version \"&gt;=1.0.0\"\n\n# Add Git package\nbrix dbt project edit --action add-git-package \\\n  --package https://github.com/org/repo.git \\\n  --revision main \\\n  --subdirectory dbt\n\n# Add local package\nbrix dbt project edit --action add-local-package \\\n  --package ../shared_macros\n\n# Remove package\nbrix dbt project edit --action remove-package \\\n  --package dbt-labs/dbt_utils \\\n  --force\n\n# Update package version\nbrix dbt project edit --action update-package-version \\\n  --package dbt-labs/dbt_utils \\\n  --package-version \"&gt;=2.0.0\"\n</code></pre>"},{"location":"user-guide/projects/#package-shortcuts","title":"Package Shortcuts","text":"<p>When using interactive mode, brix recognizes common package shortcuts:</p> Shortcut Full Package <code>dbt_utils</code> dbt-labs/dbt_utils <code>elementary</code> elementary-data/elementary <code>codegen</code> dbt-labs/codegen <code>audit_helper</code> dbt-labs/audit_helper <code>dbt_expectations</code> calogica/dbt_expectations <code>dbt_date</code> calogica/dbt_date"},{"location":"user-guide/projects/#best-practices","title":"Best Practices","text":"<ol> <li>Use semantic versioning for package versions (<code>&gt;=1.0.0,&lt;2.0.0</code>)</li> <li>Pin to specific versions in production for reproducibility</li> <li>Run <code>dbt deps</code> after modifying packages</li> <li>Use persist_docs with Databricks Unity Catalog</li> <li>Organize models in subdirectories (staging, marts, etc.)</li> </ol>"},{"location":"user-guide/sqlfluff/","title":"SQLFluff Setup Guide for dbt with Databricks","text":"<p>A comprehensive guide to configuring SQLFluff for linting and formatting SQL in dbt projects targeting Databricks.</p>"},{"location":"user-guide/sqlfluff/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Overview</li> <li>Installation</li> <li>Configuration</li> <li>Rule Categories</li> <li>Recommended Configuration</li> <li>CI/CD Integration</li> <li>Multi-Project / Monorepo Setup</li> <li>Troubleshooting</li> <li>Sources</li> </ol>"},{"location":"user-guide/sqlfluff/#overview","title":"Overview","text":"<p>SQLFluff is a modular SQL linter and auto-formatter with support for multiple dialects and templated code. When combined with dbt, it provides powerful capabilities for enforcing SQL standards across your analytics codebase.</p>"},{"location":"user-guide/sqlfluff/#key-benefits","title":"Key Benefits","text":"<ul> <li>Dialect-aware: Native support for Databricks SQL syntax via the <code>databricks</code> dialect</li> <li>dbt Integration: Understands Jinja templating and dbt macros like <code>ref()</code>, <code>source()</code>, and <code>var()</code></li> <li>Auto-fix: Can automatically fix many rule violations</li> <li>Extensible: Granular rule configuration for team-specific standards</li> </ul>"},{"location":"user-guide/sqlfluff/#installation","title":"Installation","text":""},{"location":"user-guide/sqlfluff/#required-packages","title":"Required Packages","text":"<pre><code>pip install sqlfluff sqlfluff-templater-dbt dbt-databricks\n</code></pre> <p>Or with uv:</p> <pre><code>uv add sqlfluff sqlfluff-templater-dbt dbt-databricks\n</code></pre>"},{"location":"user-guide/sqlfluff/#package-descriptions","title":"Package Descriptions","text":"Package Purpose <code>sqlfluff</code> Core linter and formatter <code>sqlfluff-templater-dbt</code> dbt templater for parsing Jinja/dbt syntax <code>dbt-databricks</code> dbt adapter for Databricks (required by templater)"},{"location":"user-guide/sqlfluff/#configuration","title":"Configuration","text":""},{"location":"user-guide/sqlfluff/#file-structure","title":"File Structure","text":"<p>SQLFluff uses two configuration files in your project root:</p> <pre><code>your-dbt-project/\n\u251c\u2500\u2500 .sqlfluff           # Main configuration\n\u251c\u2500\u2500 .sqlfluffignore     # Files/directories to ignore\n\u251c\u2500\u2500 dbt_project.yml\n\u251c\u2500\u2500 profiles.yml        # Local profiles for linting\n\u2514\u2500\u2500 models/\n</code></pre>"},{"location":"user-guide/sqlfluff/#sqlfluff-configuration","title":".sqlfluff Configuration","text":"<p>Create a <code>.sqlfluff</code> file in your dbt project root:</p> <pre><code>[sqlfluff]\ndialect = databricks\ntemplater = dbt\nmax_line_length = 120\nencoding = utf-8\n\n[sqlfluff:templater:dbt]\nproject_dir = ./\nprofiles_dir = ~/.dbt/\nprofile = default\ntarget = dev\n</code></pre>"},{"location":"user-guide/sqlfluff/#configuration-options","title":"Configuration Options","text":"Setting Description Default <code>dialect</code> SQL dialect (<code>databricks</code> or <code>sparksql</code>) Required <code>templater</code> Template engine (<code>dbt</code> or <code>jinja</code>) <code>jinja</code> <code>max_line_length</code> Maximum characters per line 80 <code>project_dir</code> Path to dbt_project.yml <code>./</code> <code>profiles_dir</code> Path to profiles.yml directory <code>~/.dbt/</code> <code>profile</code> dbt profile name Required <code>target</code> dbt target within profile Required"},{"location":"user-guide/sqlfluff/#dialect-choice-databricks-vs-sparksql","title":"Dialect Choice: <code>databricks</code> vs <code>sparksql</code>","text":"<ul> <li><code>databricks</code>: Recommended for Databricks. Inherits from <code>sparksql</code> and adds Unity Catalog syntax support.</li> <li><code>sparksql</code>: Use for generic Apache Spark SQL without Databricks-specific features.</li> </ul>"},{"location":"user-guide/sqlfluff/#sqlfluffignore","title":".sqlfluffignore","text":"<p>Create a <code>.sqlfluffignore</code> file to exclude directories:</p> <pre><code>target/\ndbt_packages/\ndbt_modules/\nmacros/\nlogs/\n</code></pre>"},{"location":"user-guide/sqlfluff/#rule-categories","title":"Rule Categories","text":"<p>SQLFluff organizes rules into categories with two-letter prefixes:</p>"},{"location":"user-guide/sqlfluff/#layout-rules-lt","title":"Layout Rules (LT)","text":"<p>Spacing, indentation, and formatting. - <code>LT01</code>: Trailing whitespace - <code>LT02</code>: Incorrect indentation - <code>LT05</code>: Comma placement - <code>LT12</code>: End of file newline</p>"},{"location":"user-guide/sqlfluff/#capitalisation-rules-cp","title":"Capitalisation Rules (CP)","text":"<p>Case consistency for SQL elements. - <code>CP01</code>: Keywords (SELECT, FROM, WHERE) - <code>CP02</code>: Identifiers (table/column names) - <code>CP03</code>: Functions - <code>CP04</code>: Literals (TRUE, FALSE, NULL)</p>"},{"location":"user-guide/sqlfluff/#aliasing-rules-al","title":"Aliasing Rules (AL)","text":"<p>Alias best practices. - <code>AL01</code>: Implicit aliasing (missing AS keyword) - <code>AL02</code>: Table aliases in column references - <code>AL07</code>: Avoid aliases entirely (disabled by default)</p>"},{"location":"user-guide/sqlfluff/#ambiguous-rules-am","title":"Ambiguous Rules (AM)","text":"<p>Query clarity. - <code>AM01</code>: Distinct used with GROUP BY - <code>AM04</code>: Nested CASE statements - <code>AM05</code>: Join condition qualification</p>"},{"location":"user-guide/sqlfluff/#structure-rules-st","title":"Structure Rules (ST)","text":"<p>Query logic. - <code>ST05</code>: CTE usage instead of subqueries - <code>ST06</code>: Select targets ordering - <code>ST07</code>: Using USING clause in joins</p>"},{"location":"user-guide/sqlfluff/#convention-rules-cv","title":"Convention Rules (CV)","text":"<p>Code style preferences. - <code>CV06</code>: Statement terminators (semicolons) - <code>CV09</code>: Blocked words - <code>CV11</code>: Casting style (CAST vs ::)</p>"},{"location":"user-guide/sqlfluff/#references-rules-rf","title":"References Rules (RF)","text":"<p>Column/table qualification. - <code>RF01</code>: Quoted identifier consistency - <code>RF02</code>: Column qualification in multi-table queries</p>"},{"location":"user-guide/sqlfluff/#recommended-configuration","title":"Recommended Configuration","text":""},{"location":"user-guide/sqlfluff/#complete-sqlfluff-for-databricks-dbt","title":"Complete .sqlfluff for Databricks + dbt","text":"<pre><code>[sqlfluff]\ndialect = databricks\ntemplater = dbt\nmax_line_length = 120\nexclude_rules = LT05, AM04, ST06\nwarnings = RF02\nencoding = utf-8\nlarge_file_skip_byte_limit = 1000000\nprocesses = 2\n\n[sqlfluff:indentation]\nindent_unit = space\ntab_space_size = 4\nindented_joins = false\nindented_ctes = false\nindented_using_on = true\nindented_on_contents = true\n\n[sqlfluff:layout:type:comma]\nline_position = trailing\n\n[sqlfluff:templater:dbt]\nproject_dir = ./\nprofiles_dir = ./\nprofile = default\ntarget = dev\n\n[sqlfluff:rules:capitalisation.keywords]\ncapitalisation_policy = upper\n\n[sqlfluff:rules:capitalisation.identifiers]\ncapitalisation_policy = lower\n\n[sqlfluff:rules:capitalisation.functions]\ncapitalisation_policy = upper\n\n[sqlfluff:rules:capitalisation.literals]\ncapitalisation_policy = upper\n\n[sqlfluff:rules:capitalisation.types]\ncapitalisation_policy = upper\n\n[sqlfluff:rules:aliasing.table]\naliasing = explicit\n\n[sqlfluff:rules:aliasing.column]\naliasing = explicit\n\n[sqlfluff:rules:aliasing.expression]\nallow_scalar = false\n\n[sqlfluff:rules:convention.casting_style]\npreferred_type_casting_style = cast\n</code></pre>"},{"location":"user-guide/sqlfluff/#dbt-labs-style-guide-alternative","title":"dbt Labs Style Guide Alternative","text":"<p>For lowercase keywords (per dbt style guide):</p> <pre><code>[sqlfluff:rules:capitalisation.keywords]\ncapitalisation_policy = lower\n\n[sqlfluff:rules:capitalisation.functions]\ncapitalisation_policy = lower\n\n[sqlfluff:rules:capitalisation.literals]\ncapitalisation_policy = lower\n</code></pre>"},{"location":"user-guide/sqlfluff/#local-profilesyml-for-linting","title":"Local profiles.yml for Linting","text":"<p>Create a minimal <code>profiles.yml</code> in your project for local/CI linting without requiring database access:</p> <pre><code>default:\n  target: dev\n  outputs:\n    dev:\n      type: databricks\n      host: \"{{ env_var('DBT_HOST', 'dummy.cloud.databricks.com') }}\"\n      http_path: \"{{ env_var('DBT_HTTP_PATH', '/sql/1.0/warehouses/dummy') }}\"\n      token: \"{{ env_var('DBT_TOKEN', 'dummy') }}\"\n      catalog: main\n      schema: dev\n</code></pre>"},{"location":"user-guide/sqlfluff/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"user-guide/sqlfluff/#pre-commit-hook","title":"Pre-commit Hook","text":"<p>Add to <code>.pre-commit-config.yaml</code>:</p> <pre><code>repos:\n  - repo: https://github.com/sqlfluff/sqlfluff\n    rev: 3.2.5  # Use latest stable version\n    hooks:\n      - id: sqlfluff-lint\n        additional_dependencies:\n          - dbt-databricks&gt;=1.8.0\n          - sqlfluff-templater-dbt\n        args: [--dialect, databricks]\n      - id: sqlfluff-fix\n        additional_dependencies:\n          - dbt-databricks&gt;=1.8.0\n          - sqlfluff-templater-dbt\n        args: [--dialect, databricks, --force]\n</code></pre>"},{"location":"user-guide/sqlfluff/#github-actions-workflow","title":"GitHub Actions Workflow","text":"<p>Create <code>.github/workflows/sqlfluff.yml</code>:</p> <pre><code>name: SQLFluff Lint\n\non:\n  pull_request:\n    paths:\n      - 'models/**/*.sql'\n      - '.sqlfluff'\n\njobs:\n  sqlfluff:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n\n      - name: Install dependencies\n        run: |\n          pip install sqlfluff sqlfluff-templater-dbt dbt-databricks\n\n      - name: Create dummy profiles.yml\n        run: |\n          cat &gt; profiles.yml &lt;&lt; 'EOF'\n          default:\n            target: dev\n            outputs:\n              dev:\n                type: databricks\n                host: dummy.cloud.databricks.com\n                http_path: /sql/1.0/warehouses/dummy\n                token: dummy\n                catalog: main\n                schema: dev\n          EOF\n\n      - name: Lint SQL\n        run: sqlfluff lint models/ --format github-annotation-native\n</code></pre>"},{"location":"user-guide/sqlfluff/#github-pr-annotations","title":"GitHub PR Annotations","text":"<p>Use <code>--format github-annotation-native</code> to get inline PR annotations:</p> <pre><code>sqlfluff lint models/ --format github-annotation-native\n</code></pre>"},{"location":"user-guide/sqlfluff/#multi-project-monorepo-setup","title":"Multi-Project / Monorepo Setup","text":"<p>When working with multiple dbt projects in a single repository, there's an important limitation to understand.</p>"},{"location":"user-guide/sqlfluff/#the-templater-limitation","title":"The Templater Limitation","text":"<p>The <code>templater</code> setting cannot be overridden in subdirectory <code>.sqlfluff</code> files. SQLFluff explicitly requires the templater to be set in the root config where SQLFluff is executed:</p> <p>\"To use the dbt templater, you must set <code>templater = dbt</code> in the <code>.sqlfluff</code> config file in the directory where sqlfluff is run.\"</p> <p>This means you cannot have a structure like:</p> <pre><code>repo/\n\u251c\u2500\u2500 .sqlfluff                    # templater = jinja (global)\n\u2514\u2500\u2500 assets/dbt_projects/\n    \u251c\u2500\u2500 project_a/\n    \u2502   \u2514\u2500\u2500 .sqlfluff            # templater = dbt (IGNORED!)\n    \u2514\u2500\u2500 project_b/\n        \u2514\u2500\u2500 .sqlfluff            # templater = dbt (IGNORED!)\n</code></pre>"},{"location":"user-guide/sqlfluff/#what-can-be-inherited","title":"What CAN Be Inherited","text":"<p>All other settings follow hierarchical inheritance and can be overridden per subdirectory: - Rules and rule configurations - Indentation settings - Capitalisation policies - Line length - Dialect (though this typically stays consistent)</p>"},{"location":"user-guide/sqlfluff/#recommended-approach-per-project-execution","title":"Recommended Approach: Per-Project Execution","text":"<p>The most reliable solution is to run SQLFluff from within each project directory:</p> <pre><code>repo/\n\u251c\u2500\u2500 .sqlfluff.shared             # Shared rules (not used directly)\n\u2514\u2500\u2500 assets/dbt_projects/\n    \u251c\u2500\u2500 project_a/\n    \u2502   \u251c\u2500\u2500 .sqlfluff            # templater = dbt, includes shared rules\n    \u2502   \u251c\u2500\u2500 .sqlfluffignore\n    \u2502   \u251c\u2500\u2500 dbt_project.yml\n    \u2502   \u2514\u2500\u2500 models/\n    \u2514\u2500\u2500 project_b/\n        \u251c\u2500\u2500 .sqlfluff            # templater = jinja (different!)\n        \u251c\u2500\u2500 .sqlfluffignore\n        \u251c\u2500\u2500 dbt_project.yml\n        \u2514\u2500\u2500 models/\n</code></pre>"},{"location":"user-guide/sqlfluff/#cli-usage","title":"CLI Usage","text":"<pre><code># Lint project_a\ncd assets/dbt_projects/project_a &amp;&amp; sqlfluff lint models/\n\n# Lint project_b\ncd assets/dbt_projects/project_b &amp;&amp; sqlfluff lint models/\n\n# Or use absolute paths\nsqlfluff lint assets/dbt_projects/project_a/models/ \\\n  --config assets/dbt_projects/project_a/.sqlfluff\n</code></pre>"},{"location":"user-guide/sqlfluff/#github-actions-for-multiple-projects","title":"GitHub Actions for Multiple Projects","text":"<pre><code>name: SQLFluff Lint\n\non:\n  pull_request:\n    paths:\n      - 'assets/dbt_projects/**/*.sql'\n      - 'assets/dbt_projects/**/.sqlfluff'\n\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        project: [project_a, project_b, project_c]\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n\n      - name: Install dependencies\n        run: pip install sqlfluff sqlfluff-templater-dbt dbt-databricks\n\n      - name: Lint ${{ matrix.project }}\n        working-directory: assets/dbt_projects/${{ matrix.project }}\n        run: sqlfluff lint models/ --format github-annotation-native\n</code></pre>"},{"location":"user-guide/sqlfluff/#pre-commit-for-multiple-projects","title":"Pre-commit for Multiple Projects","text":"<pre><code>repos:\n  - repo: local\n    hooks:\n      - id: sqlfluff-lint-project-a\n        name: SQLFluff Lint Project A\n        entry: bash -c 'cd assets/dbt_projects/project_a &amp;&amp; sqlfluff lint models/'\n        language: system\n        files: ^assets/dbt_projects/project_a/.*\\.sql$\n        pass_filenames: false\n\n      - id: sqlfluff-lint-project-b\n        name: SQLFluff Lint Project B\n        entry: bash -c 'cd assets/dbt_projects/project_b &amp;&amp; sqlfluff lint models/'\n        language: system\n        files: ^assets/dbt_projects/project_b/.*\\.sql$\n        pass_filenames: false\n</code></pre>"},{"location":"user-guide/sqlfluff/#alternative-jinja-templater-with-dbt-builtins","title":"Alternative: Jinja Templater with dbt Builtins","text":"<p>If per-project execution is too complex, you can use the Jinja templater globally with dbt builtin support:</p> <pre><code>[sqlfluff]\ndialect = databricks\ntemplater = jinja\nmax_line_length = 120\n\n[sqlfluff:templater:jinja]\napply_dbt_builtins = True\n</code></pre> <p>This provides basic support for dbt macros (<code>ref()</code>, <code>source()</code>, <code>var()</code>, <code>is_incremental()</code>) without requiring the full dbt templater. Trade-offs:</p> Aspect dbt Templater Jinja with Builtins Accuracy Full dbt compilation Basic macro stubs Custom macros Fully supported Not supported Database access Sometimes required Never required Speed Slower Faster Multi-project Per-project only Global config works"},{"location":"user-guide/sqlfluff/#vs-code-configuration-for-multi-project","title":"VS Code Configuration for Multi-Project","text":"<p>Configure VS Code to use the file's directory for config discovery:</p> <pre><code>{\n  \"sqlfluff.workingDirectory\": \"${fileDirname}\",\n  \"sqlfluff.ignoreLocalConfig\": false\n}\n</code></pre> <p>This allows VS Code to find the nearest <code>.sqlfluff</code> file when linting.</p>"},{"location":"user-guide/sqlfluff/#environment-variables","title":"Environment Variables","text":"<p>You can use environment variables to dynamically set project paths:</p> <pre><code>[sqlfluff:templater:dbt]\nproject_dir = ./\nprofiles_dir = ./\n</code></pre> <p>Override in CI/CD: <pre><code>export DBT_PROJECT_DIR=/path/to/project_a\nexport DBT_PROFILES_DIR=/path/to/project_a\nsqlfluff lint models/\n</code></pre></p>"},{"location":"user-guide/sqlfluff/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/sqlfluff/#common-errors","title":"Common Errors","text":""},{"location":"user-guide/sqlfluff/#1-could-not-find-profile-named-xxx","title":"1. \"Could not find profile named 'XXX'\"","text":"<p>Cause: SQLFluff cannot locate your dbt profile.</p> <p>Solution: Ensure <code>profiles_dir</code> points to the directory containing <code>profiles.yml</code>: <pre><code>[sqlfluff:templater:dbt]\nprofiles_dir = ./  # or ~/.dbt/\n</code></pre></p>"},{"location":"user-guide/sqlfluff/#2-adapter-is-undefined","title":"2. \"'adapter' is undefined\"","text":"<p>Cause: Using Jinja templater instead of dbt templater, or missing dbt adapter.</p> <p>Solution: 1. Set <code>templater = dbt</code> in <code>.sqlfluff</code> 2. Install the dbt adapter: <code>pip install dbt-databricks</code></p>"},{"location":"user-guide/sqlfluff/#3-database-connection-errors-in-ci","title":"3. Database Connection Errors in CI","text":"<p>Cause: The dbt templater attempts database connections for compile-time operations.</p> <p>Solution: Create a dummy <code>profiles.yml</code> with placeholder credentials. Many SQLFluff operations don't require actual database access.</p>"},{"location":"user-guide/sqlfluff/#4-slow-performance-with-dbt-templater","title":"4. Slow Performance with dbt Templater","text":"<p>Cause: dbt templater is slower than Jinja templater due to full dbt compilation.</p> <p>Solutions: - Use Jinja templater for IDE/git hooks: <code>templater = jinja</code> - Use dbt templater for CI where accuracy matters - Increase <code>processes</code> setting for parallelism - Add <code>large_file_skip_byte_limit</code> to skip very large files</p>"},{"location":"user-guide/sqlfluff/#5-macro-linting-issues","title":"5. Macro Linting Issues","text":"<p>Cause: SQLFluff may not properly lint SQL generated by macros.</p> <p>Workaround: This is a known limitation. Complex macros may require inline ignores: <pre><code>-- sqlfluff:disable=all\n{{ my_complex_macro() }}\n-- sqlfluff:enable=all\n</code></pre></p>"},{"location":"user-guide/sqlfluff/#debugging-commands","title":"Debugging Commands","text":"<pre><code># Parse a file to see how SQLFluff interprets it\nsqlfluff parse models/my_model.sql\n\n# Lint with verbose output\nsqlfluff lint models/my_model.sql -v\n\n# Test configuration\nsqlfluff lint --dialect databricks --templater dbt models/my_model.sql\n\n# Fix issues automatically\nsqlfluff fix models/my_model.sql\n</code></pre>"},{"location":"user-guide/sqlfluff/#templater-comparison","title":"Templater Comparison","text":"Feature dbt Templater Jinja Templater Speed Slower Faster Accuracy Higher (full dbt context) Lower Database needed Sometimes No Macro support Full Limited Best for CI/CD IDE, git hooks"},{"location":"user-guide/sqlfluff/#sources","title":"Sources","text":""},{"location":"user-guide/sqlfluff/#official-documentation","title":"Official Documentation","text":"<ul> <li>SQLFluff Documentation</li> <li>dbt Templater Configuration</li> <li>SQLFluff Rules Reference</li> <li>SQLFluff Pre-commit Setup</li> </ul>"},{"location":"user-guide/sqlfluff/#github-resources","title":"GitHub Resources","text":"<ul> <li>SQLFluff GitHub Repository</li> <li>SQLFluff GitHub Actions</li> <li>sqlfluff-templater-dbt on PyPI</li> </ul>"},{"location":"user-guide/sqlfluff/#dbt-resources","title":"dbt Resources","text":"<ul> <li>dbt SQL Style Guide</li> <li>dbt Labs Jaffle Shop .sqlfluff</li> <li>Best Practices for dbt on Databricks</li> </ul>"},{"location":"user-guide/sqlfluff/#community-troubleshooting","title":"Community &amp; Troubleshooting","text":"<ul> <li>Troubleshooting dbt Profiles for SQLFluff</li> <li>SQLFluff Troubleshooting Guide</li> <li>Databricks Compatibility Issue #6006</li> <li>VS Code Multi-Project Discussion #83</li> <li>SQLFluff Configuration Hierarchy</li> </ul>"}]}